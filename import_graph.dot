digraph "import_graph" {
  "Aesop.Frontend.Attribute" -> "Aesop.Frontend";
  "Aesop.Frontend.Command" -> "Aesop.Frontend";
  "Aesop.Frontend.RuleExpr" -> "Aesop.Frontend";
  "Aesop.Frontend.Tactic" -> "Aesop.Frontend";
  "Lean.Elab.Term" -> "Lean.Elab.Do";
  "Lean.Elab.BindersUtil" -> "Lean.Elab.Do";
  "Lean.Elab.PatternVar" -> "Lean.Elab.Do";
  "Lean.Elab.Quotation.Util" -> "Lean.Elab.Do";
  "Lean.Parser.Do" -> "Lean.Elab.Do";
  "Lean.Elab.MacroArgUtil" -> "Lean.Elab.Macro";
  "Aesop.Tree.AddRapp" -> "Aesop.Tree";
  "Aesop.Tree.Check" -> "Aesop.Tree";
  "Aesop.Tree.Data" -> "Aesop.Tree";
  "Aesop.Tree.ExtractProof" -> "Aesop.Tree";
  "Aesop.Tree.ExtractScript" -> "Aesop.Tree";
  "Aesop.Tree.Free" -> "Aesop.Tree";
  "Aesop.Tree.RunMetaM" -> "Aesop.Tree";
  "Aesop.Tree.State" -> "Aesop.Tree";
  "Aesop.Tree.Tracing" -> "Aesop.Tree";
  "Aesop.Tree.Traversal" -> "Aesop.Tree";
  "Aesop.Tree.TreeM" -> "Aesop.Tree";
  "Aesop.Tree.UnsafeQueue" -> "Aesop.Tree";
  "Lean.Parser.Term" -> "Lean.Elab.Tactic.Match";
  "Lean.Elab.Match" -> "Lean.Elab.Tactic.Match";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Match";
  "Lean.Elab.Tactic.Induction" -> "Lean.Elab.Tactic.Match";
  "Init.Data.Option.Basic" -> "Init.Data.Option.BasicAux";
  "Init.Util" -> "Init.Data.Option.BasicAux";
  "Lean.Meta.ReduceEval" -> "Lean.ParserCompiler";
  "Lean.KeyedDeclsAttribute" -> "Lean.ParserCompiler";
  "Lean.ParserCompiler.Attribute" -> "Lean.ParserCompiler";
  "Lean.Parser.Extension" -> "Lean.ParserCompiler";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.PhaseExt";
  "Std.Classes.Cast" -> "Std.Data.Int.Lemmas";
  "Std.Data.Nat.Lemmas" -> "Std.Data.Int.Lemmas";
  "Std.Data.Int.Basic" -> "Std.Data.Int.Lemmas";
  "Std.Data.Option.Basic" -> "Std.Data.Int.Lemmas";
  "Std.Tactic.NormCast.Lemmas" -> "Std.Data.Int.Lemmas";
  "Std.Tactic.RCases" -> "Std.Data.Int.Lemmas";
  "Init.Data.Array.Basic" -> "Init.Data.Array";
  "Init.Data.Array.QSort" -> "Init.Data.Array";
  "Init.Data.Array.BinSearch" -> "Init.Data.Array";
  "Init.Data.Array.InsertionSort" -> "Init.Data.Array";
  "Init.Data.Array.DecidableEq" -> "Init.Data.Array";
  "Init.Data.Array.Mem" -> "Init.Data.Array";
  "Init.Data.Array.BasicAux" -> "Init.Data.Array";
  "Lean.Compiler.LCNF.DependsOn" -> "Lean.Compiler.LCNF.Simp.JpCases";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.Simp.JpCases";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.Simp.JpCases";
  "Lean.Compiler.LCNF.Simp.Basic" -> "Lean.Compiler.LCNF.Simp.JpCases";
  "Lean.Compiler.LCNF.Simp.DiscrM" -> "Lean.Compiler.LCNF.Simp.JpCases";
  "Lean.Meta.Basic" -> "Lean.Elab.DeclUtil";
  "Lean.Meta.Check" -> "Lean.Elab.DeclUtil";
  "Lean.PrettyPrinter.Delaborator" -> "Lean.PrettyPrinter";
  "Lean.PrettyPrinter.Parenthesizer" -> "Lean.PrettyPrinter";
  "Lean.PrettyPrinter.Formatter" -> "Lean.PrettyPrinter";
  "Lean.Parser.Module" -> "Lean.PrettyPrinter";
  "Lean.ParserCompiler" -> "Lean.PrettyPrinter";
  "Lean.Compiler.Options" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.Passes" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.ToDecl" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.Check" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.PullLetDecls" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.Main";
  "Lean.Compiler.LCNF.CSE" -> "Lean.Compiler.LCNF.Main";
  "Lean.Elab.Command" -> "Std.Lean.Command";
  "Lean.Elab.SetOption" -> "Std.Lean.Command";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Client";
  "Lean.Data.Json" -> "Lean.Data.Lsp.Client";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Assumption";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Simp.DiscrM";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.Simp.DiscrM";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.Simp.DiscrM";
  "Lean.Compiler.LCNF.Simp.Basic" -> "Lean.Compiler.LCNF.Simp.DiscrM";
  "Lean.Data.Name" -> "Lean.Data.OpenDecl";
  "Std.Classes.Order" -> "Std.Data.PairingHeap";
  "Std.Logic" -> "Std.Data.PairingHeap";
  "Std.Data.RBMap.Basic" -> "Std.Data.RBMap";
  "Std.Data.RBMap.WF" -> "Std.Data.RBMap";
  "Std.Data.List.Init.Lemmas" -> "Mathlib.Init.Control.Combinators";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Control.Combinators";
  "Lean.CoreM" -> "Lean.PrettyPrinter.Formatter";
  "Lean.Parser.Extension" -> "Lean.PrettyPrinter.Formatter";
  "Lean.Parser.StrInterpolation" -> "Lean.PrettyPrinter.Formatter";
  "Lean.KeyedDeclsAttribute" -> "Lean.PrettyPrinter.Formatter";
  "Lean.ParserCompiler.Attribute" -> "Lean.PrettyPrinter.Formatter";
  "Lean.PrettyPrinter.Basic" -> "Lean.PrettyPrinter.Formatter";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Data.Int.Basic";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Init.Data.Int.Basic";
  "Mathlib.Init.ZeroOne" -> "Mathlib.Init.Data.Int.Basic";
  "Std.Data.Int.Lemmas" -> "Mathlib.Init.Data.Int.Basic";
  "Std.Tactic.NoMatch" -> "Std.Data.Array.Init.Lemmas";
  "Std.Tactic.HaveI" -> "Std.Data.Array.Init.Lemmas";
  "Std.Classes.LawfulMonad" -> "Std.Data.Array.Init.Lemmas";
  "Std.Data.List.Init.Lemmas" -> "Std.Data.Array.Init.Lemmas";
  "Std.Data.Array.Init.Basic" -> "Std.Data.Array.Init.Lemmas";
  "Lean.Meta.Basic" -> "Lean.Meta.DecLevel";
  "Lean.Meta.InferType" -> "Lean.Meta.DecLevel";
  "Lean.Util.ForEachExprWhere" -> "Lean.Elab.Match";
  "Lean.Meta.Match.Match" -> "Lean.Elab.Match";
  "Lean.Meta.GeneralizeVars" -> "Lean.Elab.Match";
  "Lean.Meta.ForEachExpr" -> "Lean.Elab.Match";
  "Lean.Elab.BindersUtil" -> "Lean.Elab.Match";
  "Lean.Elab.PatternVar" -> "Lean.Elab.Match";
  "Lean.Elab.Quotation.Precheck" -> "Lean.Elab.Match";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Match";
  "Lean" -> "Mathlib.Tactic.Basic";
  "Std" -> "Mathlib.Tactic.Basic";
  "Mathlib.Tactic.Cases" -> "Mathlib.Tactic.Basic";
  "Lean.Elab.Import" -> "Lean.Elab.Frontend";
  "Lean.Elab.Command" -> "Lean.Elab.Frontend";
  "Lean.Util.Profile" -> "Lean.Elab.Frontend";
  "Lean.Server.References" -> "Lean.Elab.Frontend";
  "Lean" -> "Mathlib.Data.Array.Defs";
  "Init.Data.Nat.Div" -> "Mathlib.Init.Data.Nat.Div";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Data.Nat.Div";
  "Lean.Structure" -> "Lean.Elab.DeclModifiers";
  "Lean.Elab.Attributes" -> "Lean.Elab.DeclModifiers";
  "Lean" -> "Mathlib.Mathport.Rename";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.AuxDeclCache";
  "Lean.Compiler.LCNF.DeclHash" -> "Lean.Compiler.LCNF.AuxDeclCache";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.AuxDeclCache";
  "Std.Data.Nat.Lemmas" -> "Mathlib.Init.Data.Nat.Lemmas";
  "Mathlib.Init.Data.Nat.Basic" -> "Mathlib.Init.Data.Nat.Lemmas";
  "Mathlib.Init.Data.Nat.Div" -> "Mathlib.Init.Data.Nat.Lemmas";
  "Mathlib.Init.Algebra.Functions" -> "Mathlib.Init.Data.Nat.Lemmas";
  "Lean.Elab.Command" -> "Std.Linter.UnreachableTactic";
  "Lean.Linter.Util" -> "Std.Linter.UnreachableTactic";
  "Std.Lean.Command" -> "Std.Linter.UnreachableTactic";
  "Std.Tactic.Unreachable" -> "Std.Linter.UnreachableTactic";
  "Lean.Util.CollectLevelParams" -> "Std.Tactic.Lint.Misc";
  "Lean.Meta.ForEachExpr" -> "Std.Tactic.Lint.Misc";
  "Std.Tactic.Lint.Basic" -> "Std.Tactic.Lint.Misc";
  "Std.Data.Array.Basic" -> "Std.Tactic.Lint.Misc";
  "Lean.Util.ForEachExpr" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Replace";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic.Replace";
  "Lean.Elab.Command" -> "Lean.Elab.Deriving.Basic";
  "Aesop.Builder" -> "Aesop.RuleSet";
  "Aesop.Index" -> "Aesop.RuleSet";
  "Aesop.Rule" -> "Aesop.RuleSet";
  "Init.Data.UInt.Basic" -> "Init.Data.Char.Basic";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.LiveVars";
  "Lean.Compiler.IR.FreeVars" -> "Lean.Compiler.IR.LiveVars";
  "Init.Data.Fin.Basic" -> "Init.Data.UInt.Basic";
  "Init.System.Platform" -> "Init.Data.UInt.Basic";
  "Aesop.Util.Basic" -> "Aesop.Tracing";
  "Lean.Elab.Term" -> "Aesop.Tracing";
  "Lean.Meta.Tactic.Simp" -> "Aesop.Tracing";
  "Lean.Elab.Tactic.Simp" -> "Std.Tactic.SqueezeScope";
  "Std.Tactic.SimpTrace" -> "Std.Tactic.SqueezeScope";
  "Lean.Meta.Tactic.Constructor" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Meta.Tactic.Assert" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Meta.Tactic.Clear" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Meta.Tactic.Rename" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Tactic.ElabTerm";
  "Lean.Parser.Tactic" -> "Std.Tactic.ByCases";
  "Lean.Compiler.LCNF.Simp.Basic" -> "Lean.Compiler.LCNF.Simp.FunDeclInfo";
  "Lean.Data.Json.Stream" -> "Lean.Data.Json";
  "Lean.Data.Json.Printer" -> "Lean.Data.Json";
  "Lean.Data.Json.Parser" -> "Lean.Data.Json";
  "Lean.Data.Json.FromToJson" -> "Lean.Data.Json";
  "Lean.AuxRecursor" -> "Lean.Meta.Constructions";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Constructions";
  "Aesop.Tree.RunMetaM" -> "Aesop.Tree.TreeM";
  "Aesop.Tree.TreeM" -> "Aesop.Tree.Free";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Capabilities" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Client" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Communication" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Diagnostics" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Extra" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.InitShutdown" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Internal" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.LanguageFeatures" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.TextSync" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Utf16" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Workspace" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.Ipc" -> "Lean.Data.Lsp";
  "Lean.Data.Lsp.CodeActions" -> "Lean.Data.Lsp";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Simp.ConstantFold";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.Simp.ConstantFold";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.Simp.ConstantFold";
  "Lean.Expr" -> "Lean.Util.ForEachExprWhere";
  "Lean.Util.MonadCache" -> "Lean.Util.ForEachExprWhere";
  "Std.Control.ForInStep.Basic" -> "Std.Control.ForInStep";
  "Std.Control.ForInStep.Lemmas" -> "Std.Control.ForInStep";
  "Lean.Util.CollectFVars" -> "Lean.Util";
  "Lean.Util.CollectLevelParams" -> "Lean.Util";
  "Lean.Util.CollectMVars" -> "Lean.Util";
  "Lean.Util.FindMVar" -> "Lean.Util";
  "Lean.Util.FindLevelMVar" -> "Lean.Util";
  "Lean.Util.MonadCache" -> "Lean.Util";
  "Lean.Util.PPExt" -> "Lean.Util";
  "Lean.Util.Path" -> "Lean.Util";
  "Lean.Util.Profile" -> "Lean.Util";
  "Lean.Util.RecDepth" -> "Lean.Util";
  "Lean.Util.ShareCommon" -> "Lean.Util";
  "Lean.Util.Sorry" -> "Lean.Util";
  "Lean.Util.Trace" -> "Lean.Util";
  "Lean.Util.FindExpr" -> "Lean.Util";
  "Lean.Util.ReplaceExpr" -> "Lean.Util";
  "Lean.Util.ForEachExpr" -> "Lean.Util";
  "Lean.Util.ForEachExprWhere" -> "Lean.Util";
  "Lean.Util.ReplaceLevel" -> "Lean.Util";
  "Lean.Util.FoldConsts" -> "Lean.Util";
  "Lean.Util.SCC" -> "Lean.Util";
  "Lean.Util.OccursCheck" -> "Lean.Util";
  "Lean.Util.Paths" -> "Lean.Util";
  "Lean.Util.HasConstCache" -> "Lean.Util";
  "Lean.KeyedDeclsAttribute" -> "Lean.PrettyPrinter.Basic";
  "Qq.Macro" -> "Qq.Match";
  "Qq.MetaM" -> "Qq.Match";
  "Qq.ForLean.Do" -> "Qq.Match";
  "Qq.SortLocalDecls" -> "Qq.Match";
  "Init.Core" -> "Init.Control.Basic";
  "Lean.Elab.InfoTree.Main" -> "Std.Lean.InfoTree";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.MonadScope";
  "Lean.Compiler.NoncomputableAttr" -> "Lean.Elab.PreDefinition.Basic";
  "Lean.Util.CollectLevelParams" -> "Lean.Elab.PreDefinition.Basic";
  "Lean.Meta.AbstractNestedProofs" -> "Lean.Elab.PreDefinition.Basic";
  "Lean.Elab.RecAppSyntax" -> "Lean.Elab.PreDefinition.Basic";
  "Lean.Elab.DefView" -> "Lean.Elab.PreDefinition.Basic";
  "Lean.Meta.Tactic.Generalize" -> "Lean.Elab.Tactic.Generalize";
  "Lean.Meta.Check" -> "Lean.Elab.Tactic.Generalize";
  "Lean.Meta.Tactic.Intro" -> "Lean.Elab.Tactic.Generalize";
  "Lean.Elab.Binders" -> "Lean.Elab.Tactic.Generalize";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Generalize";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Generalize";
  "Init.Data.ToString.Basic" -> "Init.Data.ToString";
  "Init.Data.ToString.Macro" -> "Init.Data.ToString";
  "Lean.Compiler.ExportAttr" -> "Lean.Compiler.IR.Borrow";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.Borrow";
  "Lean.Compiler.IR.NormIds" -> "Lean.Compiler.IR.Borrow";
  "Std.Data.Int.Lemmas" -> "Std.Data.Int.DivMod";
  "Lean.Data.PersistentHashSet" -> "Std.Lean.PersistentHashSet";
  "Lean.Meta.InferType" -> "Lean.Compiler.LCNF.Types";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac.RuleApplicationWithMVarInfo";
  "Std.Data.HashMap.Basic" -> "Std.Data.HashMap.WF";
  "Std.Data.List.Lemmas" -> "Std.Data.HashMap.WF";
  "Std.Data.Array.Lemmas" -> "Std.Data.HashMap.WF";
  "Std.Tactic.ShowTerm" -> "Std.Data.HashMap.WF";
  "Mathlib.Logic.Basic" -> "Mathlib.Algebra.NeZero";
  "Mathlib.Init.ZeroOne" -> "Mathlib.Algebra.NeZero";
  "Mathlib.Init.Algebra.Order" -> "Mathlib.Algebra.NeZero";
  "Std.Util.TermUnsafe" -> "Mathlib.Util.Pickle";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.ExpandResetReuse";
  "Lean.Compiler.IR.NormIds" -> "Lean.Compiler.IR.ExpandResetReuse";
  "Lean.Compiler.IR.FreeVars" -> "Lean.Compiler.IR.ExpandResetReuse";
  "Lean.Data.Options" -> "Lean.Linter.Basic";
  "Lean.Parser.Command" -> "Lean.Parser.Syntax";
  "Lean.Meta.Constructions" -> "Lean.Elab.ComputedFields";
  "Lean.Compiler.ImplementedByAttr" -> "Lean.Elab.ComputedFields";
  "Lean.Elab.PreDefinition.WF.Eqns" -> "Lean.Elab.ComputedFields";
  "Lean.Meta.Tactic.Rewrite" -> "Lean.Elab.Tactic.Rewrite";
  "Lean.Meta.Tactic.Replace" -> "Lean.Elab.Tactic.Rewrite";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Rewrite";
  "Lean.Elab.Tactic.Config" -> "Lean.Elab.Tactic.Rewrite";
  "Aesop.Options" -> "Aesop.Search.SearchM";
  "Aesop.Search.Expansion.Simp.Basic" -> "Aesop.Search.SearchM";
  "Aesop.Search.Queue.Class" -> "Aesop.Search.SearchM";
  "Aesop.Profiling" -> "Aesop.Search.SearchM";
  "Aesop.RuleSet" -> "Aesop.Search.SearchM";
  "Lean.LazyInitExtension" -> "Lean.Meta.Tactic.SplitIf";
  "Lean.Meta.Tactic.Cases" -> "Lean.Meta.Tactic.SplitIf";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.SplitIf";
  "Lean.Meta.Constructions" -> "Lean.Meta.IndPredBelow";
  "Lean.Meta.Match.Match" -> "Lean.Meta.IndPredBelow";
  "Lean.Util.ReplaceExpr" -> "Lean.Util.InstantiateLevelParams";
  "Lean.Data.Json" -> "Lean.Data.Lsp.TextSync";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.TextSync";
  "Lean.Meta.Tactic.Cases" -> "Lean.Elab.PreDefinition.WF.PackDomain";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.PackDomain";
  "Aesop.Frontend.Attribute" -> "Aesop.Frontend.Tactic";
  "Aesop.Frontend.RuleExpr" -> "Aesop.Frontend.Tactic";
  "Aesop.Options" -> "Aesop.Frontend.Tactic";
  "Aesop.Search.Expansion.Simp.Basic" -> "Aesop.Frontend.Tactic";
  "Lean.Elab.Command" -> "Lean.Server.Rpc.Deriving";
  "Lean.Elab.Term" -> "Lean.Server.Rpc.Deriving";
  "Lean.Elab.Deriving.Basic" -> "Lean.Server.Rpc.Deriving";
  "Lean.Elab.Deriving.Util" -> "Lean.Server.Rpc.Deriving";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.Rpc.Deriving";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.Relation.Trans";
  "Mathlib.Lean.Elab.Tactic.Basic" -> "Mathlib.Tactic.Relation.Trans";
  "Lean.Elab.Tactic.Location" -> "Mathlib.Tactic.Relation.Trans";
  "Lean.Meta.Check" -> "Lean.Meta.Match.Match";
  "Lean.Meta.Closure" -> "Lean.Meta.Match.Match";
  "Lean.Meta.Tactic.Cases" -> "Lean.Meta.Match.Match";
  "Lean.Meta.Tactic.Contradiction" -> "Lean.Meta.Match.Match";
  "Lean.Meta.GeneralizeTelescope" -> "Lean.Meta.Match.Match";
  "Lean.Meta.Match.Basic" -> "Lean.Meta.Match.Match";
  "Lean.Meta.Basic" -> "Lean.Elab.Config";
  "Lean.Elab.ElabRules" -> "Std.Util.TermUnsafe";
  "Lean.Meta.Closure" -> "Std.Util.TermUnsafe";
  "Lean.Compiler.ImplementedByAttr" -> "Std.Util.TermUnsafe";
  "Std.Tactic.CoeExt" -> "Std.Classes.Cast";
  "Std.Util.LibraryNote" -> "Std.Classes.Cast";
  "Lean.Elab.Term" -> "Mathlib.Tactic.HigherOrder";
  "Lean.Meta.Tactic.Apply" -> "Mathlib.Tactic.HigherOrder";
  "Lean.Meta.Tactic.Assumption" -> "Mathlib.Tactic.HigherOrder";
  "Lean.Elab.DeclarationRange" -> "Mathlib.Tactic.HigherOrder";
  "Mathlib.Tactic.Attr.Register" -> "Mathlib.Tactic.HigherOrder";
  "Lean.Data.Options" -> "Lean.Data.Format";
  "Lean" -> "Mathlib.Tactic.Clear!";
  "Init.Data.Int" -> "Init.Data.Ord";
  "Init.Data.String" -> "Init.Data.Ord";
  "Lean.Meta.AppBuilder" -> "Lean.Elab.PreDefinition.MkInhabitant";
  "Lean.Compiler.InitAttr" -> "Lean.Compiler.IR.EmitUtil";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.EmitUtil";
  "Lean.Data.Format" -> "Lean.Data.Trie";
  "Lean.Server.Utils" -> "Lean.Server.FileWorker.Utils";
  "Lean.Server.Snapshots" -> "Lean.Server.FileWorker.Utils";
  "Lean.Server.AsyncList" -> "Lean.Server.FileWorker.Utils";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.FileWorker.Utils";
  "Lean.Meta.Check" -> "Lean.Meta.Match.Basic";
  "Lean.Meta.CollectFVars" -> "Lean.Meta.Match.Basic";
  "Lean.Meta.Match.MatcherInfo" -> "Lean.Meta.Match.Basic";
  "Lean.Meta.Match.CaseArraySizes" -> "Lean.Meta.Match.Basic";
  "Std.Util.TermUnsafe" -> "Std.Tactic.Lint.Basic";
  "Std.Lean.NameMapAttribute" -> "Std.Tactic.Lint.Basic";
  "Aesop.Util" -> "Aesop.Index.Basic";
  "Lean.Elab.Calc" -> "Lean.Elab.Tactic.Calc";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Calc";
  "Lean.Parser.Term" -> "Lean.Elab.MutualDef";
  "Lean.Meta.Closure" -> "Lean.Elab.MutualDef";
  "Lean.Meta.Check" -> "Lean.Elab.MutualDef";
  "Lean.Meta.Transform" -> "Lean.Elab.MutualDef";
  "Lean.PrettyPrinter.Delaborator.Options" -> "Lean.Elab.MutualDef";
  "Lean.Elab.Command" -> "Lean.Elab.MutualDef";
  "Lean.Elab.Match" -> "Lean.Elab.MutualDef";
  "Lean.Elab.DefView" -> "Lean.Elab.MutualDef";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.MutualDef";
  "Lean.Elab.PreDefinition.Main" -> "Lean.Elab.MutualDef";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab.MutualDef";
  "Lean.Meta" -> "Std.Lean.Meta.UnusedNames";
  "Std.Data.String" -> "Std.Lean.Meta.UnusedNames";
  "Lean.Expr" -> "Lean.Data.Lsp.Internal";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Internal";
  "Lean.Attributes" -> "Lean.Meta.Match.MatchPatternAttr";
  "Lean" -> "Qq.Macro";
  "Qq.ForLean.ReduceEval" -> "Qq.Macro";
  "Qq.ForLean.ToExpr" -> "Qq.Macro";
  "Qq.Typ" -> "Qq.Macro";
  "Lean.Elab.Term" -> "Lean.Elab.MatchAltView";
  "Lean.Util.CollectLevelParams" -> "Lean.Elab.Declaration";
  "Lean.Elab.DeclUtil" -> "Lean.Elab.Declaration";
  "Lean.Elab.DefView" -> "Lean.Elab.Declaration";
  "Lean.Elab.Inductive" -> "Lean.Elab.Declaration";
  "Lean.Elab.Structure" -> "Lean.Elab.Declaration";
  "Lean.Elab.MutualDef" -> "Lean.Elab.Declaration";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab.Declaration";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.Tactic.Simp.SimpCongrTheorems";
  "Lean.Util.Recognizers" -> "Lean.Meta.Tactic.Simp.SimpCongrTheorems";
  "Lean.Util.CollectMVars" -> "Lean.Meta.Tactic.Simp.SimpCongrTheorems";
  "Lean.Meta.Basic" -> "Lean.Meta.Tactic.Simp.SimpCongrTheorems";
  "Init.System.IO" -> "Lean.Server.FileWorker";
  "Lean.Data.RBMap" -> "Lean.Server.FileWorker";
  "Lean.Environment" -> "Lean.Server.FileWorker";
  "Lean.Data.Lsp" -> "Lean.Server.FileWorker";
  "Lean.Data.Json.FromToJson" -> "Lean.Server.FileWorker";
  "Lean.Util.Paths" -> "Lean.Server.FileWorker";
  "Lean.LoadDynlib" -> "Lean.Server.FileWorker";
  "Lean.Server.Utils" -> "Lean.Server.FileWorker";
  "Lean.Server.Snapshots" -> "Lean.Server.FileWorker";
  "Lean.Server.AsyncList" -> "Lean.Server.FileWorker";
  "Lean.Server.References" -> "Lean.Server.FileWorker";
  "Lean.Server.FileWorker.Utils" -> "Lean.Server.FileWorker";
  "Lean.Server.FileWorker.RequestHandling" -> "Lean.Server.FileWorker";
  "Lean.Server.FileWorker.WidgetRequests" -> "Lean.Server.FileWorker";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.FileWorker";
  "Lean.Widget.InteractiveDiagnostic" -> "Lean.Server.FileWorker";
  "Lean.Log" -> "Lean.Elab.SetOption";
  "Lean.Elab.InfoTree" -> "Lean.Elab.SetOption";
  "Aesop.Index.Basic" -> "Aesop.RuleTac.Basic";
  "Aesop.Options" -> "Aesop.RuleTac.Basic";
  "Aesop.Script" -> "Aesop.RuleTac.Basic";
  "Aesop.Util" -> "Aesop.RuleTac.Basic";
  "Std.Lean.Meta.SavedState" -> "Aesop.RuleTac.Basic";
  "Mathlib.Tactic.DeriveToExpr" -> "Mathlib.Tactic.ToExpr";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.Testing";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Testing";
  "Init.Data.List.Basic" -> "Init.Data.String.Basic";
  "Init.Data.Char.Basic" -> "Init.Data.String.Basic";
  "Init.Data.Option.Basic" -> "Init.Data.String.Basic";
  "Qq.Macro" -> "Qq.Delab";
  "Lean.Meta.Match.MatchPatternAttr" -> "Lean.Elab.PatternVar";
  "Lean.Elab.Arg" -> "Lean.Elab.PatternVar";
  "Lean.Elab.MatchAltView" -> "Lean.Elab.PatternVar";
  "Init.SimpLemmas" -> "Init.Data.List.Basic";
  "Init.Data.Nat.Basic" -> "Init.Data.List.Basic";
  "Std.Lean.Meta.Basic" -> "Std.Lean.Meta.AssertHypotheses";
  "Lean.Util.CollectMVars" -> "Lean.Meta.CollectMVars";
  "Lean.Meta.Basic" -> "Lean.Meta.CollectMVars";
  "Init.Data.Array.Basic" -> "Init.Data.Array.BasicAux";
  "Init.Data.Nat.Linear" -> "Init.Data.Array.BasicAux";
  "Init.NotationExtra" -> "Init.Data.Array.BasicAux";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.TypeName";
  "Lean.Meta.Transform" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Injection" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Refl" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Cases" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Subst" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Simp.Types" -> "Lean.Meta.Injective";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Meta.Injective";
  "Lean.Parser.Basic" -> "Lean.Parser.StrInterpolation";
  "Lean.Expr" -> "Lean.Elab.RecAppSyntax";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Lean.Expr";
  "Mathlib.Lean.Expr.Traverse" -> "Mathlib.Lean.Expr";
  "Mathlib.Lean.Expr.ReplaceRec" -> "Mathlib.Lean.Expr";
  "Std.Data.HashMap.Basic" -> "Std.Data.HashMap";
  "Std.Data.HashMap.WF" -> "Std.Data.HashMap";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Injection";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Injection";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Injection";
  "Lean.Meta.Tactic.Subst" -> "Lean.Meta.Tactic.Injection";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic.Injection";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Injection";
  "Lean.Elab.MacroArgUtil" -> "Std.Util.ExtendedBinder";
  "Lean.Linter.MissingDocs" -> "Std.Util.ExtendedBinder";
  "Lean.Elab.Eval" -> "Mathlib.Tactic.RunCmd";
  "Std.Util.TermUnsafe" -> "Mathlib.Tactic.RunCmd";
  "Lean.Elab.InfoTree" -> "Lean.Widget.Basic";
  "Lean.Message" -> "Lean.Widget.Basic";
  "Lean.Server.Rpc.Basic" -> "Lean.Widget.Basic";
  "Lean.Server.InfoUtils" -> "Lean.Widget.Basic";
  "Lean.Environment" -> "Lean.Compiler.ClosedTermCache";
  "Std.Tactic.NormCast.Ext" -> "Mathlib.Tactic.NormCast.Tactic";
  "Std.Tactic.CoeExt" -> "Mathlib.Tactic.NormCast.Tactic";
  "Mathlib.Tactic.SudoSetOption" -> "Mathlib.Tactic.NormCast.Tactic";
  "Mathlib.Lean.Meta.Simp" -> "Mathlib.Tactic.NormCast.Tactic";
  "Mathlib.Algebra.Group.Defs" -> "Mathlib.Tactic.NormCast.Tactic";
  "Mathlib.Data.Nat.Cast.Defs" -> "Mathlib.Tactic.NormCast.Tactic";
  "Aesop.Builder.Constructors" -> "Aesop.Builder.Default";
  "Aesop.Builder.NormSimp" -> "Aesop.Builder.Default";
  "Aesop.Builder.Tactic" -> "Aesop.Builder.Default";
  "Lean.Elab.Tactic.Simp" -> "Lean.Elab.Tactic.Conv.Simp";
  "Lean.Elab.Tactic.Split" -> "Lean.Elab.Tactic.Conv.Simp";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Simp";
  "Std.Data.RBMap.WF" -> "Std.Data.RBMap.Alter";
  "Lean.Parser.Term" -> "Lean.Elab.Deriving.Util";
  "Lean.Elab.Term" -> "Lean.Elab.Deriving.Util";
  "Lean" -> "Mathlib.Tactic.MkIffOfInductiveProp";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.MkIffOfInductiveProp";
  "Mathlib.Tactic.LeftRight" -> "Mathlib.Tactic.MkIffOfInductiveProp";
  "Lean.Meta.KAbstract" -> "Lean.Meta.Tactic.Generalize";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Generalize";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Generalize";
  "Lean.Meta.Tactic.FVarSubst" -> "Lean.Meta.Tactic.Generalize";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic.Generalize";
  "Lean.Data.KVMap" -> "Lean.Compiler.IR.Basic";
  "Lean.Data.Name" -> "Lean.Compiler.IR.Basic";
  "Lean.Data.Format" -> "Lean.Compiler.IR.Basic";
  "Lean.Compiler.ExternAttr" -> "Lean.Compiler.IR.Basic";
  "Lean.DeclarationRange" -> "Lean.Server.Requests";
  "Lean.Data.Json" -> "Lean.Server.Requests";
  "Lean.Data.Lsp" -> "Lean.Server.Requests";
  "Lean.Elab.Command" -> "Lean.Server.Requests";
  "Lean.Server.FileSource" -> "Lean.Server.Requests";
  "Lean.Server.FileWorker.Utils" -> "Lean.Server.Requests";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.Requests";
  "Lean.Meta.Tactic.LinearArith.Nat" -> "Lean.Meta.Tactic.LinearArith.Main";
  "Init.Notation" -> "Init.Tactics";
  "Lean.Data.Options" -> "Lean.Util.RecDepth";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Renaming";
  "Std.Tactic.Basic" -> "Std.Tactic.Ext";
  "Std.Tactic.RCases" -> "Std.Tactic.Ext";
  "Std.Tactic.Ext.Attr" -> "Std.Tactic.Ext";
  "Std.Data.HashMap" -> "Aesop.Util.UnionFind";
  "Lean.Elab.BuiltinTerm" -> "Std.CodeAction.Basic";
  "Lean.Elab.BuiltinNotation" -> "Std.CodeAction.Basic";
  "Std.Lean.Name" -> "Std.CodeAction.Basic";
  "Std.Lean.InfoTree" -> "Std.CodeAction.Basic";
  "Std.CodeAction.Attr" -> "Std.CodeAction.Basic";
  "Init.Control.State" -> "Init.Control.EState";
  "Init.Control.Except" -> "Init.Control.EState";
  "Init.Data.ToString.Basic" -> "Init.Control.EState";
  "Std.Lean.Meta.Basic" -> "Std.Lean.Meta.InstantiateMVars";
  "Lean.Parser.Extension" -> "Lean.Parser.Extra";
  "Lean.PrettyPrinter.Parenthesizer" -> "Lean.Parser.Extra";
  "Lean.PrettyPrinter.Formatter" -> "Lean.Parser.Extra";
  "Init.Core" -> "Init.Control.Id";
  "Lean.Elab.Command" -> "Std.Tactic.GuardMsgs";
  "Std.CodeAction.Basic" -> "Std.Tactic.GuardMsgs";
  "Std.Lean.Position" -> "Std.Tactic.GuardMsgs";
  "Lean.Util.CollectLevelParams" -> "Lean.Elab.BuiltinCommand";
  "Lean.Meta.Reduce" -> "Lean.Elab.BuiltinCommand";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab.BuiltinCommand";
  "Lean.Elab.Eval" -> "Lean.Elab.BuiltinCommand";
  "Lean.Elab.Command" -> "Lean.Elab.BuiltinCommand";
  "Lean.Elab.Open" -> "Lean.Elab.BuiltinCommand";
  "Lean.Elab.SetOption" -> "Lean.Elab.BuiltinCommand";
  "Lean.PrettyPrinter" -> "Lean.Elab.BuiltinCommand";
  "Lean.Util.MonadCache" -> "Lean.MetavarContext";
  "Lean.LocalContext" -> "Lean.MetavarContext";
  "Std.Tactic.Basic" -> "Std.Logic";
  "Std.Tactic.Lint.Misc" -> "Std.Logic";
  "Lean.Expr" -> "Lean.Compiler.ExternAttr";
  "Lean.Environment" -> "Lean.Compiler.ExternAttr";
  "Lean.Attributes" -> "Lean.Compiler.ExternAttr";
  "Lean.ProjFns" -> "Lean.Compiler.ExternAttr";
  "Lean.Meta.Basic" -> "Lean.Compiler.ExternAttr";
  "Std.Lean.Meta.Basic" -> "Std.Lean.Meta.Clear";
  "Aesop.Builder.Basic" -> "Aesop.Builder.Tactic";
  "Lean.Meta.Offset" -> "Lean.Meta.ExprDefEq";
  "Lean.Meta.UnificationHint" -> "Lean.Meta.ExprDefEq";
  "Lean.Util.OccursCheck" -> "Lean.Meta.ExprDefEq";
  "Lean.Meta.Tactic.LinearArith.Basic" -> "Lean.Meta.Tactic.LinearArith.Simp";
  "Lean.Meta.Tactic.LinearArith.Nat.Simp" -> "Lean.Meta.Tactic.LinearArith.Simp";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.ApplyHyps";
  "Lean.Meta.Tactic.Simp" -> "Mathlib.Tactic.Attr.Register";
  "Mathlib.Tactic.LabelAttr" -> "Mathlib.Tactic.Attr.Register";
  "Lean.Data.HashSet" -> "Lean.Util.PtrSet";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.SimpCase";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.SimpCase";
  "Qq.Macro" -> "Qq.MetaM";
  "Lean.Util.FindMVar" -> "Lean.Meta.Tactic.Apply";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.Tactic.Apply";
  "Lean.Meta.CollectMVars" -> "Lean.Meta.Tactic.Apply";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Apply";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.Assumption";
  "Init.System.IO" -> "Lean.Server.AsyncList";
  "Lean.Data.Json" -> "Lean.Data.Lsp.CodeActions";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.CodeActions";
  "Lean.Data.Lsp.Diagnostics" -> "Lean.Data.Lsp.CodeActions";
  "Lean.Data.Name" -> "Lean.Hygiene";
  "Lean.Data.Options" -> "Lean.Hygiene";
  "Lean.Data.Format" -> "Lean.Hygiene";
  "Lean.Data.Lsp.Communication" -> "Lean.Server.Utils";
  "Lean.Data.Lsp.Diagnostics" -> "Lean.Server.Utils";
  "Lean.Data.Lsp.Extra" -> "Lean.Server.Utils";
  "Lean.Data.Lsp.TextSync" -> "Lean.Server.Utils";
  "Lean.Server.InfoUtils" -> "Lean.Server.Utils";
  "Lean.Util.FindMVar" -> "Lean.Elab.App";
  "Lean.Parser.Term" -> "Lean.Elab.App";
  "Lean.Meta.KAbstract" -> "Lean.Elab.App";
  "Lean.Meta.Tactic.ElimInfo" -> "Lean.Elab.App";
  "Lean.Elab.Term" -> "Lean.Elab.App";
  "Lean.Elab.Binders" -> "Lean.Elab.App";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.App";
  "Lean.Elab.Arg" -> "Lean.Elab.App";
  "Lean.Elab.RecAppSyntax" -> "Lean.Elab.App";
  "Lean.Meta.Tactic.Unfold" -> "Lean.Elab.Tactic.Unfold";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Unfold";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Unfold";
  "Std.Util.TermUnsafe" -> "Mathlib.Tactic.Trace";
  "Lean.Elab.Tactic.ElabTerm" -> "Mathlib.Tactic.Trace";
  "Lean.Meta.Eval" -> "Mathlib.Tactic.Trace";
  "Std.Data.Nat.Lemmas" -> "Std.Data.Array.Lemmas";
  "Std.Data.List.Lemmas" -> "Std.Data.Array.Lemmas";
  "Std.Tactic.HaveI" -> "Std.Data.Array.Lemmas";
  "Std.Tactic.Simpa" -> "Std.Data.Array.Lemmas";
  "Lean.Meta.Eqns" -> "Lean.Meta.Tactic.Unfold";
  "Lean.Meta.Tactic.Delta" -> "Lean.Meta.Tactic.Unfold";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.Unfold";
  "Init.Data.Array.Basic" -> "Init.Meta";
  "Init.Data.Option.BasicAux" -> "Init.Meta";
  "Lean.Util.HasConstCache" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Meta.CasesOn" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Meta.Match.Match" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Meta.Tactic.Cleanup" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Elab.RecAppSyntax" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Lean.Elab.PreDefinition.Structural.BRecOn" -> "Lean.Elab.PreDefinition.WF.Fix";
  "Mathlib.Tactic.NormCast.Tactic" -> "Mathlib.Tactic.NormCast";
  "Std.CodeAction.Attr" -> "Std.CodeAction";
  "Std.CodeAction.Basic" -> "Std.CodeAction";
  "Std.CodeAction.Misc" -> "Std.CodeAction";
  "Lean.Meta.Tactic.Rewrite" -> "Lean.Elab.PreDefinition.WF.Eqns";
  "Lean.Meta.Tactic.Split" -> "Lean.Elab.PreDefinition.WF.Eqns";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.Eqns";
  "Lean.Elab.PreDefinition.Eqns" -> "Lean.Elab.PreDefinition.WF.Eqns";
  "Lean" -> "Mathlib.Tactic.Find";
  "Mathlib.Tactic.Cache" -> "Mathlib.Tactic.Find";
  "Lean.Data.Json.FromToJson" -> "Lean.Server.GoTo";
  "Lean.Util.Path" -> "Lean.Server.GoTo";
  "Lean.Server.Utils" -> "Lean.Server.GoTo";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.Checker";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.Checker";
  "Lean.Compiler.BorrowedAnnotation" -> "Lean.Elab.BuiltinNotation";
  "Lean.Meta.KAbstract" -> "Lean.Elab.BuiltinNotation";
  "Lean.Meta.MatchUtil" -> "Lean.Elab.BuiltinNotation";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.BuiltinNotation";
  "Lean.Expr" -> "Lean.Util.HasConstCache";
  "Std.Data.Char" -> "Std.Data.String.Basic";
  "Std.Data.Nat.Lemmas" -> "Std.Data.String.Basic";
  "Init.WFTactics" -> "Init.Data.Array.Basic";
  "Init.Data.Nat.Basic" -> "Init.Data.Array.Basic";
  "Init.Data.Fin.Basic" -> "Init.Data.Array.Basic";
  "Init.Data.UInt.Basic" -> "Init.Data.Array.Basic";
  "Init.Data.Repr" -> "Init.Data.Array.Basic";
  "Init.Data.ToString.Basic" -> "Init.Data.Array.Basic";
  "Init.Util" -> "Init.Data.Array.Basic";
  "Init.System.IO" -> "Lean.Data.Lsp.Ipc";
  "Lean.Data.Json" -> "Lean.Data.Lsp.Ipc";
  "Lean.Data.Lsp.Communication" -> "Lean.Data.Lsp.Ipc";
  "Lean.Data.Lsp.Diagnostics" -> "Lean.Data.Lsp.Ipc";
  "Lean.Data.Lsp.Extra" -> "Lean.Data.Lsp.Ipc";
  "Lean.Elab.InfoTree.Main" -> "Lean.Elab.InheritDoc";
  "Lean.DocString" -> "Lean.Elab.InheritDoc";
  "Lean.Util.CollectFVars" -> "Lean.Meta.CollectFVars";
  "Lean.Meta.Basic" -> "Lean.Meta.CollectFVars";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Workspace";
  "Lean.Data.Json" -> "Lean.Data.Lsp.Workspace";
  "Lean.Meta.Tactic.Simp" -> "Lean.Elab.Tactic.Simp";
  "Lean.Meta.Tactic.Replace" -> "Lean.Elab.Tactic.Simp";
  "Lean.Elab.BuiltinNotation" -> "Lean.Elab.Tactic.Simp";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Simp";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Simp";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Simp";
  "Lean.Elab.Tactic.Config" -> "Lean.Elab.Tactic.Simp";
  "Lean.Data.Format" -> "Lean.Data.Json.Printer";
  "Lean.Data.Json.Basic" -> "Lean.Data.Json.Printer";
  "Lean.Data.Position" -> "Lean.Message";
  "Lean.Data.OpenDecl" -> "Lean.Message";
  "Lean.MetavarContext" -> "Lean.Message";
  "Lean.Environment" -> "Lean.Message";
  "Lean.Util.PPExt" -> "Lean.Message";
  "Lean.Util.Sorry" -> "Lean.Message";
  "Lean.Data.Json.Basic" -> "Lean.Data.Json.Parser";
  "Lean.Data.Parsec" -> "Lean.Data.Json.Parser";
  "Lean.Data.RBMap" -> "Lean.Data.PrefixTree";
  "Lean" -> "Qq.ForLean.Do";
  "Lean.Parser.Basic" -> "Lean.Parser.Attr";
  "Lean.Parser.Extra" -> "Lean.Parser.Attr";
  "Lean.Elab.ElabRules" -> "Std.Tactic.HaveI";
  "Lean.Attributes" -> "Lean.ReducibilityAttrs";
  "Lean.Data.OpenDecl" -> "Lean.ResolveName";
  "Lean.Hygiene" -> "Lean.ResolveName";
  "Lean.Modifiers" -> "Lean.ResolveName";
  "Lean.Exception" -> "Lean.ResolveName";
  "Lean.Util.MonadBacktrack" -> "Std.Lean.MonadBacktrack";
  "Lean.ScopedEnvExtension" -> "Lean.Compiler.CSimpAttr";
  "Lean.Util.Recognizers" -> "Lean.Compiler.CSimpAttr";
  "Lean.Util.ReplaceExpr" -> "Lean.Compiler.CSimpAttr";
  "Lean" -> "Mathlib.Tactic.SuccessIfFailWithMsg";
  "Std.Util.TermUnsafe" -> "Mathlib.Tactic.SuccessIfFailWithMsg";
  "Std.Data.String.Basic" -> "Mathlib.Tactic.Says";
  "Std.Tactic.GuardMsgs" -> "Mathlib.Tactic.Says";
  "Std.Data.List.Basic" -> "Mathlib.Data.String.Defs";
  "Mathlib.Mathport.Rename" -> "Mathlib.Data.String.Defs";
  "Mathlib.Init.ZeroOne" -> "Mathlib.Logic.Nonempty";
  "Mathlib.Logic.Basic" -> "Mathlib.Logic.Nonempty";
  "Lean.Util.ForEachExprWhere" -> "Lean.Elab.Deriving.Inhabited";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.Inhabited";
  "Init.SizeOf" -> "Init.WF";
  "Init.Data.Nat.Basic" -> "Init.WF";
  "Lean.Meta.InferType" -> "Lean.Meta.Check";
  "Lean" -> "Mathlib.Tactic.Coe";
  "Lean.Expr" -> "Lean.Util.CollectMVars";
  "Mathlib.Logic.Nonempty" -> "Mathlib.Logic.Function.Basic";
  "Mathlib.Init.Data.Nat.Lemmas" -> "Mathlib.Logic.Function.Basic";
  "Mathlib.Init.Set" -> "Mathlib.Logic.Function.Basic";
  "Lean.Elab.Term" -> "Lean.PrettyPrinter.Delaborator.Basic";
  "Lean.PrettyPrinter.Delaborator.Options" -> "Lean.PrettyPrinter.Delaborator.Basic";
  "Lean.PrettyPrinter.Delaborator.SubExpr" -> "Lean.PrettyPrinter.Delaborator.Basic";
  "Lean.PrettyPrinter.Delaborator.TopDownAnalyze" -> "Lean.PrettyPrinter.Delaborator.Basic";
  "Aesop.Check" -> "Aesop.Tree.Check";
  "Aesop.Tree.State" -> "Aesop.Tree.Check";
  "Aesop.Tree.Traversal" -> "Aesop.Tree.Check";
  "Aesop.Tree.TreeM" -> "Aesop.Tree.Check";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Data.Quot";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Data.Bool.Basic";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.FloatLetIn";
  "Lean.Compiler.LCNF.FVarUtil" -> "Lean.Compiler.LCNF.FloatLetIn";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.FloatLetIn";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.FloatLetIn";
  "Lean.Util.ForEachExpr" -> "Lean.Compiler.LCNF.ForEachExpr";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.ForEachExpr";
  "Init.Data.String" -> "Lean.Data.Lsp.Utf16";
  "Init.Data.Array" -> "Lean.Data.Lsp.Utf16";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Utf16";
  "Lean.Data.Position" -> "Lean.Data.Lsp.Utf16";
  "Lean.Expr" -> "Lean.Meta.Tactic.LinearArith.Basic";
  "Lean" -> "Mathlib.Tactic.PermuteGoals";
  "Std.Data.List.Basic" -> "Mathlib.Tactic.PermuteGoals";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Tactic.PermuteGoals";
  "Lean" -> "Mathlib.Tactic.Spread";
  "Lean.Environment" -> "Lean.Compiler.IR.CtorLayout";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.CtorLayout";
  "Lean.Elab.InfoTree.Types" -> "Lean.Elab.InfoTree";
  "Lean.Elab.InfoTree.Main" -> "Lean.Elab.InfoTree";
  "Lean.Data.Name" -> "Lean.Data.KVMap";
  "Lean.Meta.Tactic.LinearArith.Solver" -> "Lean.Meta.Tactic.LinearArith.Nat.Solver";
  "Lean.Meta.Tactic.LinearArith.Nat.Basic" -> "Lean.Meta.Tactic.LinearArith.Nat.Solver";
  "Aesop.Util.Basic" -> "Aesop.Util";
  "Aesop.Util.Tactic" -> "Aesop.Util";
  "Aesop.Util.UnionFind" -> "Aesop.Util";
  "Aesop.Util.UnorderedArraySet" -> "Aesop.Util";
  "Lean.Elab.Term" -> "Lean.Elab.Arg";
  "Lean" -> "Mathlib.Lean.Expr.Traverse";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Lean.Expr.Traverse";
  "Lean.Data.Name" -> "Lean.Syntax";
  "Lean.Data.Format" -> "Lean.Syntax";
  "Lean.Meta.PPGoal" -> "Lean.Widget.Diff";
  "Lean.Widget.InteractiveCode" -> "Lean.Widget.Diff";
  "Lean.Widget.InteractiveGoal" -> "Lean.Widget.Diff";
  "Lean.Data.Lsp.Extra" -> "Lean.Widget.Diff";
  "Lean.Elab.InfoTree" -> "Lean.Widget.Diff";
  "Lean.Attributes" -> "Lean.Compiler.LCNF.PassManager";
  "Lean.Environment" -> "Lean.Compiler.LCNF.PassManager";
  "Lean.Meta.Basic" -> "Lean.Compiler.LCNF.PassManager";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.PassManager";
  "Lean.Meta.Match.MatchPatternAttr" -> "Lean.Meta.Match";
  "Lean.Meta.Match.Match" -> "Lean.Meta.Match";
  "Lean.Meta.Match.CaseValues" -> "Lean.Meta.Match";
  "Lean.Meta.Match.CaseArraySizes" -> "Lean.Meta.Match";
  "Lean.Meta.Match.MatchEqs" -> "Lean.Meta.Match";
  "Lean" -> "Mathlib.Tactic.Variable";
  "Std.Tactic.TryThis" -> "Mathlib.Tactic.Variable";
  "Init.Control.Lawful" -> "Init.Control.StateCps";
  "Lean.Expr" -> "Lean.Util.ReplaceLevel";
  "Lean.Message" -> "Lean.Parser.Module";
  "Lean.Parser.Command" -> "Lean.Parser.Module";
  "Lean.Syntax" -> "Std.Lean.Position";
  "Lean.Data.Lsp.Utf16" -> "Std.Lean.Position";
  "Lean.Meta.Reduce" -> "Lean.Elab.Tactic.Conv.Basic";
  "Lean.Meta.Tactic.Apply" -> "Lean.Elab.Tactic.Conv.Basic";
  "Lean.Meta.Tactic.Replace" -> "Lean.Elab.Tactic.Conv.Basic";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Conv.Basic";
  "Lean.Elab.Tactic.BuiltinTactic" -> "Lean.Elab.Tactic.Conv.Basic";
  "Lean.Attributes" -> "Std.Lean.TagAttribute";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition";
  "Lean.Elab.PreDefinition.Structural" -> "Lean.Elab.PreDefinition";
  "Lean.Elab.PreDefinition.Main" -> "Lean.Elab.PreDefinition";
  "Lean.Elab.PreDefinition.MkInhabitant" -> "Lean.Elab.PreDefinition";
  "Lean.Elab.PreDefinition.WF" -> "Lean.Elab.PreDefinition";
  "Lean.Elab.PreDefinition.Eqns" -> "Lean.Elab.PreDefinition";
  "Mathlib.Util.Tactic" -> "Mathlib.Tactic.SwapVar";
  "Lean.Parser.Module" -> "Lean.Elab.Import";
  "Lean.Data.Json" -> "Lean.Elab.Import";
  "Lean.Data.Occurrences" -> "Lean.Meta.KAbstract";
  "Lean.HeadIndex" -> "Lean.Meta.KAbstract";
  "Lean.Meta.Basic" -> "Lean.Meta.KAbstract";
  "Lean.Meta.Tactic.Cases" -> "Lean.Elab.PreDefinition.WF.PackMutual";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.PackMutual";
  "Lean.Data.KVMap" -> "Mathlib.Data.KVMap";
  "Lean.Meta.IndPredBelow" -> "Lean.Elab.PreDefinition.Structural.IndPred";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.Structural.IndPred";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.IndPred";
  "Lean.Meta.Offset" -> "Lean.Meta.ReduceEval";
  "Mathlib.Tactic.ToAdditive" -> "Mathlib.Init.ZeroOne";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.ZeroOne";
  "Lean.Attributes" -> "Lean.Compiler.InlineAttrs";
  "Lean.Meta.Tactic.Split" -> "Lean.Elab.Tactic.Split";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Split";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Split";
  "Lean" -> "Qq.Typ";
  "Aesop.Frontend.Extension.Init" -> "Aesop.Frontend.Extension";
  "Lean" -> "Mathlib.Lean.Expr.ReplaceRec";
  "Lean.Meta" -> "Mathlib.Lean.Expr.ReplaceRec";
  "Std.Util.TermUnsafe" -> "Mathlib.Lean.Expr.ReplaceRec";
  "Mathlib.Lean.Expr.Traverse" -> "Mathlib.Lean.Expr.ReplaceRec";
  "Mathlib.Util.MemoFix" -> "Mathlib.Lean.Expr.ReplaceRec";
  "Lean" -> "Mathlib.Tactic.ProjectionNotation";
  "Lean.Elab.AuxDef" -> "Mathlib.Tactic.ProjectionNotation";
  "Std.Lean.Command" -> "Mathlib.Tactic.ProjectionNotation";
  "Lean.Data.KVMap" -> "Lean.Expr";
  "Lean.Level" -> "Lean.Expr";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.Internalize";
  "Lean.Compiler.LCNF.Bind" -> "Lean.Compiler.LCNF.Internalize";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Internalize";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp.InlineProj";
  "Std.Lean.Name" -> "Std.CodeAction.Misc";
  "Std.Lean.Position" -> "Std.CodeAction.Misc";
  "Std.CodeAction.Basic" -> "Std.CodeAction.Misc";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Simp.SimpAll";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Simp.SimpAll";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.Simp.SimpAll";
  "Std.Linter" -> "Std.Tactic.Basic";
  "Std.Tactic.NoMatch" -> "Std.Tactic.Basic";
  "Std.Tactic.GuardExpr" -> "Std.Tactic.Basic";
  "Std.Tactic.ByCases" -> "Std.Tactic.Basic";
  "Std.Tactic.SeqFocus" -> "Std.Tactic.Basic";
  "Std.Tactic.ShowTerm" -> "Std.Tactic.Basic";
  "Std.Tactic.SimpTrace" -> "Std.Tactic.Basic";
  "Lean.Elab.Tactic.ElabTerm" -> "Std.Tactic.Basic";
  "Std.Lean.Meta.Basic" -> "Std.Tactic.Basic";
  "Std.Lean.Tactic" -> "Std.Tactic.Basic";
  "Lean.Expr" -> "Lean.Util.FindExpr";
  "Lean.Util.PtrSet" -> "Lean.Util.FindExpr";
  "Aesop.Builder.Basic" -> "Aesop.Builder.Unfold";
  "Mathlib.Util.WithWeakNamespace" -> "Mathlib.Tactic.ScopedNS";
  "Std.Classes.SetNotation" -> "Std.Data.Option.Basic";
  "Std.Classes.LawfulMonad" -> "Std.Data.Option.Basic";
  "Std.Tactic.NoMatch" -> "Std.Data.Option.Basic";
  "Lean.Util.Paths" -> "Std.Tactic.Lint.Frontend";
  "Std.Tactic.Lint.Basic" -> "Std.Tactic.Lint.Frontend";
  "Aesop.Tree.Data" -> "Aesop.Tree.Traversal";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Conv.Change";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Change";
  "Init.SizeOf" -> "Init.WFTactics";
  "Init.WF" -> "Init.WFTactics";
  "Init.System.IO" -> "Init.Control.StateRef";
  "Init.Control.State" -> "Init.Control.StateRef";
  "Std.Lean.TagAttribute" -> "Std.Lean.AttributeExtra";
  "Lean.Elab.Syntax" -> "Lean.Elab.Notation";
  "Lean.Elab.AuxDef" -> "Lean.Elab.Notation";
  "Lean.Elab.BuiltinNotation" -> "Lean.Elab.Notation";
  "Aesop.Tree.Data" -> "Aesop.Tree.RunMetaM";
  "Mathlib.Data.ListM.Basic" -> "Mathlib.Data.ListM.Heartbeats";
  "Mathlib.Lean.CoreM" -> "Mathlib.Data.ListM.Heartbeats";
  "Aesop.Search.Expansion.Norm" -> "Aesop.Search.Expansion";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.ResetReuse";
  "Lean.Compiler.IR.LiveVars" -> "Lean.Compiler.IR.ResetReuse";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.ResetReuse";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.AC.Main";
  "Lean.Meta.Tactic.Refl" -> "Lean.Meta.Tactic.AC.Main";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.AC.Main";
  "Lean.Elab.Tactic.Rewrite" -> "Lean.Meta.Tactic.AC.Main";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Clear";
  "Init.Control.State" -> "Init.Data.Format.Basic";
  "Init.Data.Int.Basic" -> "Init.Data.Format.Basic";
  "Init.Data.String.Basic" -> "Init.Data.Format.Basic";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.Format";
  "Lean" -> "Mathlib.Tactic.Cache";
  "Mathlib.Logic.Nonempty" -> "Mathlib.Tactic.Cache";
  "Mathlib.Lean.Meta.DiscrTree" -> "Mathlib.Tactic.Cache";
  "Lean.Data.HashMap" -> "Std.Lean.HashMap";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac.Apply";
  "Lean.Environment" -> "Lean.Compiler.AtMostOnce";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.ReduceArity";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.ReduceArity";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.ReduceArity";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.ReduceArity";
  "Lean.Elab.App" -> "Lean.Elab.Calc";
  "Lean.Parser.Extension" -> "Lean.PrettyPrinter.Parenthesizer";
  "Lean.Parser.StrInterpolation" -> "Lean.PrettyPrinter.Parenthesizer";
  "Lean.ParserCompiler.Attribute" -> "Lean.PrettyPrinter.Parenthesizer";
  "Lean.PrettyPrinter.Basic" -> "Lean.PrettyPrinter.Parenthesizer";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Rename";
  "Aesop.Nanos" -> "Aesop.Profiling";
  "Aesop.Tree.Data" -> "Aesop.Profiling";
  "Aesop.Tracing" -> "Aesop.Profiling";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.ElimDeadBranches";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.ElimDeadBranches";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.ElimDeadBranches";
  "Init.Data.Array.Basic" -> "Init.Data.Array.QSort";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Intro";
  "Lean.Util.CollectLevelParams" -> "Lean.Compiler.LCNF.Level";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.Level";
  "Lean" -> "Mathlib.Tactic.Clear_";
  "Lean" -> "Mathlib.Tactic.GeneralizeProofs";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.GeneralizeProofs";
  "Mathlib.Init.Data.Prod" -> "Mathlib.Init.Function";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Function";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Function";
  "Mathlib.Tactic.Attr.Register" -> "Mathlib.Init.Function";
  "Mathlib.Lean.CoreM" -> "Mathlib.Util.CountHeartbeats";
  "Std.Tactic.TryThis" -> "Mathlib.Util.CountHeartbeats";
  "Lean.Expr" -> "Lean.Util.FoldConsts";
  "Lean.Environment" -> "Lean.Util.FoldConsts";
  "Init.Core" -> "Init.SimpLemmas";
  "Lean.Meta.Tactic.Delta" -> "Lean.Elab.Tactic.Delta";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Delta";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic.Delta";
  "Lean.Meta.InferType" -> "Lean.Meta.PPGoal";
  "Aesop.Index.Basic" -> "Aesop.Rule.Basic";
  "Aesop.Rule.Name" -> "Aesop.Rule.Basic";
  "Aesop.RuleTac.Basic" -> "Aesop.Rule.Basic";
  "Std.Lean.NameMapAttribute" -> "Mathlib.Tactic.Simps.NotationClass";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.Simps.NotationClass";
  "Lean.Elab.Exception" -> "Mathlib.Tactic.Simps.NotationClass";
  "Qq.MetaM" -> "Mathlib.Tactic.Simps.NotationClass";
  "Std.Tactic.Lint" -> "Mathlib.Tactic.Simps.NotationClass";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.PushProj" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.ElimDeadVars" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.SimpCase" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.ResetReuse" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.NormIds" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.Checker" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.Borrow" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.Boxing" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.RC" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.ExpandResetReuse" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.UnboxResult" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.ElimDeadBranches" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.EmitC" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.CtorLayout" -> "Lean.Compiler.IR";
  "Lean.Compiler.IR.Sorry" -> "Lean.Compiler.IR";
  "Lean.Meta.Transform" -> "Lean.Meta.Tactic.Simp.Main";
  "Lean.Meta.Tactic.Replace" -> "Lean.Meta.Tactic.Simp.Main";
  "Lean.Meta.Tactic.UnifyEq" -> "Lean.Meta.Tactic.Simp.Main";
  "Lean.Meta.Tactic.Simp.Rewrite" -> "Lean.Meta.Tactic.Simp.Main";
  "Lean.Elab.Term" -> "Std.Lean.Expr";
  "Lean.Meta.Transform" -> "Lean.Elab.PreDefinition.Structural.Preprocess";
  "Std.Classes.Order" -> "Std.Data.BinomialHeap.Basic";
  "Std.Control.ForInStep.Basic" -> "Std.Data.BinomialHeap.Basic";
  "Std.Data.Nat.Lemmas" -> "Std.Data.BinomialHeap.Basic";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.PullLetDecls" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.CSE" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.Simp" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.PullFunDecls" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.ReduceJpArity" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.JoinPoints" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.Specialize" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.ToMono" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.LambdaLifting" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.FloatLetIn" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.ReduceArity" -> "Lean.Compiler.LCNF.Passes";
  "Lean.Compiler.LCNF.ElimDeadBranches" -> "Lean.Compiler.LCNF.Passes";
  "Lean" -> "Qq.ForLean.ReduceEval";
  "Lean" -> "Mathlib.Tactic.Convert";
  "Mathlib.Tactic.Congr!" -> "Mathlib.Tactic.Convert";
  "Lean" -> "Mathlib.Tactic.Cases";
  "Std.Tactic.OpenPrivate" -> "Mathlib.Tactic.Cases";
  "Std.Data.List.Basic" -> "Mathlib.Tactic.Cases";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.Cases";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Tactic.Meta";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Meta";
  "Lean.Elab.Term" -> "Lean.Elab.Quotation.Util";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.HelpCmd";
  "Lean.Data.HashMap" -> "Lean.Data.SMap";
  "Lean.Data.PersistentHashMap" -> "Lean.Data.SMap";
  "Lean.Meta.ACLt" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Lean.Meta.Match.MatchEqsExt" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Lean.Meta.Tactic.Simp.Types" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Lean.Meta.Tactic.LinearArith.Simp" -> "Lean.Meta.Tactic.Simp.Rewrite";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac.Cases";
  "Init.Core" -> "Init.System.IOError";
  "Init.Data.UInt.Basic" -> "Init.System.IOError";
  "Init.Data.ToString.Basic" -> "Init.System.IOError";
  "Init.Data.String.Basic" -> "Init.System.IOError";
  "Init.System.IO" -> "Lean.Server.Watchdog";
  "Init.Data.ByteArray" -> "Lean.Server.Watchdog";
  "Lean.Data.RBMap" -> "Lean.Server.Watchdog";
  "Lean.Util.Paths" -> "Lean.Server.Watchdog";
  "Lean.Data.FuzzyMatching" -> "Lean.Server.Watchdog";
  "Lean.Data.Json" -> "Lean.Server.Watchdog";
  "Lean.Data.Lsp" -> "Lean.Server.Watchdog";
  "Lean.Server.Utils" -> "Lean.Server.Watchdog";
  "Lean.Server.Requests" -> "Lean.Server.Watchdog";
  "Lean.Server.References" -> "Lean.Server.Watchdog";
  "Lean.Data.HashMap" -> "Lean.Level";
  "Lean.Data.HashSet" -> "Lean.Level";
  "Lean.Data.PersistentHashMap" -> "Lean.Level";
  "Lean.Data.PersistentHashSet" -> "Lean.Level";
  "Lean.Hygiene" -> "Lean.Level";
  "Lean.Data.Name" -> "Lean.Level";
  "Lean.Data.Format" -> "Lean.Level";
  "Lean.Linter.Util" -> "Lean.Linter.Builtin";
  "Lean.Elab.Command" -> "Lean.Linter.Builtin";
  "Lean.Elab.ElabRules" -> "Std.Tactic.Unreachable";
  "Lean.Elab.Tactic.Delta" -> "Lean.Elab.Tactic.Conv.Delta";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Delta";
  "Lean.Environment" -> "Lean.Server.Completion";
  "Lean.Parser.Term" -> "Lean.Server.Completion";
  "Lean.Data.FuzzyMatching" -> "Lean.Server.Completion";
  "Lean.Data.Lsp.LanguageFeatures" -> "Lean.Server.Completion";
  "Lean.Data.Lsp.Capabilities" -> "Lean.Server.Completion";
  "Lean.Data.Lsp.Utf16" -> "Lean.Server.Completion";
  "Lean.Meta.Tactic.Apply" -> "Lean.Server.Completion";
  "Lean.Meta.Match.MatcherInfo" -> "Lean.Server.Completion";
  "Lean.Server.InfoUtils" -> "Lean.Server.Completion";
  "Lean.Parser.Extension" -> "Lean.Server.Completion";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Acyclic";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.Acyclic";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Simp.Types";
  "Lean.Meta.CongrTheorems" -> "Lean.Meta.Tactic.Simp.Types";
  "Lean.Meta.Tactic.Simp.SimpTheorems" -> "Lean.Meta.Tactic.Simp.Types";
  "Lean.Meta.Tactic.Simp.SimpCongrTheorems" -> "Lean.Meta.Tactic.Simp.Types";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.ReduceJpArity";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.ReduceJpArity";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.ReduceJpArity";
  "Std.Tactic.ByCases" -> "Std.Data.Range.Lemmas";
  "Std.Data.List.Lemmas" -> "Std.Data.Range.Lemmas";
  "Lean" -> "Mathlib.Lean.Linter";
  "Lean.Data.Json.Basic" -> "Lean.Data.Json.FromToJson";
  "Lean.Data.Json.Printer" -> "Lean.Data.Json.FromToJson";
  "Std.Data.Nat.Lemmas" -> "Std.Data.Nat.Gcd";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Compiler.LCNF.PullFunDecls" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Compiler.LCNF.FVarUtil" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Compiler.LCNF.ScopeM" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.JoinPoints";
  "Lean.Parser.Command" -> "Lean.Elab.Util";
  "Lean.KeyedDeclsAttribute" -> "Lean.Elab.Util";
  "Lean.Elab.Exception" -> "Lean.Elab.Util";
  "Std.Data.Rat.Basic" -> "Std.Data.Rat";
  "Std.Data.Rat.Lemmas" -> "Std.Data.Rat";
  "Std.Tactic.Lint.Misc" -> "Std.Tactic.Lint";
  "Std.Tactic.Lint.Simp" -> "Std.Tactic.Lint";
  "Std.Tactic.Lint.TypeClass" -> "Std.Tactic.Lint";
  "Std.Tactic.Lint.Frontend" -> "Std.Tactic.Lint";
  "Lean.Meta.Transform" -> "Lean.Elab.Deriving.FromToJson";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.FromToJson";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.FromToJson";
  "Lean.Data.Json.FromToJson" -> "Lean.Elab.Deriving.FromToJson";
  "Lean" -> "Mathlib.Tactic.CasesM";
  "Lean.Linter.UnusedVariables" -> "Lean.Widget.InteractiveDiagnostic";
  "Lean.Server.Utils" -> "Lean.Widget.InteractiveDiagnostic";
  "Lean.Widget.InteractiveGoal" -> "Lean.Widget.InteractiveDiagnostic";
  "Lean.Compiler.LCNF" -> "Lean.Compiler.Main";
  "Init.Control.Basic" -> "Init.Control";
  "Init.Control.State" -> "Init.Control";
  "Init.Control.StateRef" -> "Init.Control";
  "Init.Control.Id" -> "Init.Control";
  "Init.Control.Except" -> "Init.Control";
  "Init.Control.Reader" -> "Init.Control";
  "Init.Control.Option" -> "Init.Control";
  "Init.Control.Lawful" -> "Init.Control";
  "Init.Control.StateCps" -> "Init.Control";
  "Init.Control.ExceptCps" -> "Init.Control";
  "Lean.Data.Json" -> "Lean.Data.Lsp.Basic";
  "Lean.Data.JsonRpc" -> "Lean.Data.Lsp.Basic";
  "Aesop.Frontend.Extension" -> "Aesop.Frontend.Attribute";
  "Aesop.Frontend.RuleExpr" -> "Aesop.Frontend.Attribute";
  "Lean.Meta.WHNF" -> "Lean.Meta.Coe";
  "Lean.Meta.Transform" -> "Lean.Meta.Coe";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.Coe";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Coe";
  "Lean.Data.Lsp" -> "Lean.Server.FileSource";
  "Lean.Expr" -> "Lean.Util.ForEachExpr";
  "Lean.Util.MonadCache" -> "Lean.Util.ForEachExpr";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.InferType";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.InferType";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.InferType";
  "Lean.Compiler.LCNF.OtherDecl" -> "Lean.Compiler.LCNF.InferType";
  "Init.System.Platform" -> "Init.System.FilePath";
  "Init.Data.String.Basic" -> "Init.System.FilePath";
  "Init.Data.Repr" -> "Init.System.FilePath";
  "Init.Data.ToString.Basic" -> "Init.System.FilePath";
  "Lean.Elab.Quotation.Precheck" -> "Lean.Elab.Binders";
  "Lean.Elab.Term" -> "Lean.Elab.Binders";
  "Lean.Elab.BindersUtil" -> "Lean.Elab.Binders";
  "Lean.Log" -> "Lean.Elab.Open";
  "Lean.Elab.Util" -> "Lean.Elab.Open";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Elab.Tactic.Conv.Congr";
  "Lean.Meta.Tactic.Congr" -> "Lean.Elab.Tactic.Conv.Congr";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Congr";
  "Lean.Data.Lsp.Extra" -> "Lean.Server.Rpc.RequestHandling";
  "Lean.Server.Requests" -> "Lean.Server.Rpc.RequestHandling";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.Rpc.RequestHandling";
  "Lean.Structure" -> "Lean.Meta.AppBuilder";
  "Lean.Util.Recognizers" -> "Lean.Meta.AppBuilder";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.AppBuilder";
  "Lean.Meta.Check" -> "Lean.Meta.AppBuilder";
  "Lean.Meta.DecLevel" -> "Lean.Meta.AppBuilder";
  "Lean.PrettyPrinter" -> "Lean.Widget.InteractiveCode";
  "Lean.Server.Rpc.Basic" -> "Lean.Widget.InteractiveCode";
  "Lean.Server.InfoUtils" -> "Lean.Widget.InteractiveCode";
  "Lean.Widget.TaggedText" -> "Lean.Widget.InteractiveCode";
  "Lean.Widget.Basic" -> "Lean.Widget.InteractiveCode";
  "Lean" -> "Mathlib.Tactic.Congr!";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Tactic.Congr!";
  "Std.Logic" -> "Mathlib.Tactic.Congr!";
  "Std.Tactic.RCases" -> "Mathlib.Tactic.Congr!";
  "Aesop.RuleTac.Apply" -> "Aesop.RuleTac";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac";
  "Aesop.RuleTac.Cases" -> "Aesop.RuleTac";
  "Aesop.RuleTac.Forward" -> "Aesop.RuleTac";
  "Aesop.RuleTac.RuleApplicationWithMVarInfo" -> "Aesop.RuleTac";
  "Aesop.RuleTac.Tactic" -> "Aesop.RuleTac";
  "Lean.Util.ForEachExprWhere" -> "Lean.Compiler.LCNF.Closure";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Closure";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac.Forward";
  "Std.Lean.Meta.UnusedNames" -> "Aesop.RuleTac.Forward";
  "Std.Lean.Meta.AssertHypotheses" -> "Aesop.RuleTac.Forward";
  "Lean.Meta.Basic" -> "Lean.Meta.GlobalInstances";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.GlobalInstances";
  "Std.Linter.UnreachableTactic" -> "Std.Linter";
  "Std.Linter.UnnecessarySeqFocus" -> "Std.Linter";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.ElimDeadBranches";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.ElimDeadBranches";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.ElimDeadBranches";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.ElimDeadBranches";
  "Lean.Message" -> "Mathlib.Lean.Message";
  "Init.Data.Array.Basic" -> "Init.Data.ByteArray.Basic";
  "Init.Data.Array.Subarray" -> "Init.Data.ByteArray.Basic";
  "Init.Data.UInt.Basic" -> "Init.Data.ByteArray.Basic";
  "Init.Data.Option.Basic" -> "Init.Data.ByteArray.Basic";
  "Init.SimpLemmas" -> "Init.Control.Lawful";
  "Init.Control.Except" -> "Init.Control.Lawful";
  "Init.Control.StateRef" -> "Init.Control.Lawful";
  "Lean.Util.Trace" -> "Lean.Compiler.Options";
  "Lean.Data.Options" -> "Lean.Compiler.Options";
  "Lean.Elab" -> "Mathlib.Lean.Meta";
  "Lean.Meta.Tactic.Assert" -> "Mathlib.Lean.Meta";
  "Lean.Meta.Tactic.Clear" -> "Mathlib.Lean.Meta";
  "Std.Data.Option.Basic" -> "Mathlib.Lean.Meta";
  "Std.Data.List.Basic" -> "Mathlib.Lean.Meta";
  "Aesop.Tracing" -> "Aesop.Tree.ExtractScript";
  "Aesop.Tree.Traversal" -> "Aesop.Tree.ExtractScript";
  "Lean.Expr" -> "Lean.Meta.DiscrTreeTypes";
  "Lean.Meta.Basic" -> "Lean.Elab.PreDefinition.Structural.Basic";
  "Lean.Meta.ForEachExpr" -> "Lean.Elab.PreDefinition.Structural.Basic";
  "Lean.Server.FileWorker.RequestHandling" -> "Lean.Server.CodeActions";
  "Lean.Server.InfoUtils" -> "Lean.Server.CodeActions";
  "Init.Control.Basic" -> "Init.Control.State";
  "Init.Control.Id" -> "Init.Control.State";
  "Init.Control.Except" -> "Init.Control.State";
  "Lean.Meta.AppBuilder" -> "Lean.Elab.Term";
  "Lean.Meta.CollectMVars" -> "Lean.Elab.Term";
  "Lean.Meta.Coe" -> "Lean.Elab.Term";
  "Lean.Linter.Deprecated" -> "Lean.Elab.Term";
  "Lean.Elab.Config" -> "Lean.Elab.Term";
  "Lean.Elab.Level" -> "Lean.Elab.Term";
  "Lean.Elab.DeclModifiers" -> "Lean.Elab.Term";
  "Lean.Meta.Transform" -> "Lean.Elab.PreDefinition.WF.Ite";
  "Aesop.Tree.RunMetaM" -> "Aesop.Tree.Tracing";
  "Aesop.Tracing" -> "Aesop.Tree.Tracing";
  "Lean.Runtime" -> "Lean.Compiler.IR.RC";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.RC";
  "Lean.Compiler.IR.LiveVars" -> "Lean.Compiler.IR.RC";
  "Lean.Meta.InferType" -> "Lean.Compiler.LCNF.MonoTypes";
  "Lean.Compiler.LCNF.Util" -> "Lean.Compiler.LCNF.MonoTypes";
  "Lean.Compiler.LCNF.BaseTypes" -> "Lean.Compiler.LCNF.MonoTypes";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.MonoTypes";
  "Init.System.IO" -> "Lean.Server.Snapshots";
  "Lean.Elab.Import" -> "Lean.Server.Snapshots";
  "Lean.Elab.Command" -> "Lean.Server.Snapshots";
  "Lean.Widget.InteractiveDiagnostic" -> "Lean.Server.Snapshots";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.Subst";
  "Lean.Environment" -> "Lean.Structure";
  "Lean.ProjFns" -> "Lean.Structure";
  "Lean.Meta.Basic" -> "Qq.SortLocalDecls";
  "Lean.Parser.Basic" -> "Lean.Parser";
  "Lean.Parser.Level" -> "Lean.Parser";
  "Lean.Parser.Term" -> "Lean.Parser";
  "Lean.Parser.Tactic" -> "Lean.Parser";
  "Lean.Parser.Command" -> "Lean.Parser";
  "Lean.Parser.Module" -> "Lean.Parser";
  "Lean.Parser.Syntax" -> "Lean.Parser";
  "Lean.Parser.Do" -> "Lean.Parser";
  "Lean.Data.Options" -> "Lean.Compiler.LCNF.ConfigOptions";
  "Lean.Data.Options" -> "Lean.Linter.Util";
  "Lean.Server.InfoUtils" -> "Lean.Linter.Util";
  "Lean.Linter.Basic" -> "Lean.Linter.Util";
  "Lean.Environment" -> "Lean.AuxRecursor";
  "Std.Data.Char" -> "Std.Data.String.Lemmas";
  "Std.Data.Nat.Lemmas" -> "Std.Data.String.Lemmas";
  "Std.Data.List.Lemmas" -> "Std.Data.String.Lemmas";
  "Std.Data.String.Basic" -> "Std.Data.String.Lemmas";
  "Std.Tactic.Ext.Attr" -> "Std.Data.String.Lemmas";
  "Std.Tactic.Simpa" -> "Std.Data.String.Lemmas";
  "Lean.Data.PrefixTree" -> "Lean.Data.NameTrie";
  "Lean.Linter.Util" -> "Lean.Linter";
  "Lean.Linter.Builtin" -> "Lean.Linter";
  "Lean.Linter.Deprecated" -> "Lean.Linter";
  "Lean.Linter.UnusedVariables" -> "Lean.Linter";
  "Lean.Linter.MissingDocs" -> "Lean.Linter";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.ElimDead";
  "Lean.DeclarationRange" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Data.Json" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Data.Lsp" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Server.FileWorker.Utils" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Server.Requests" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Server.Completion" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Server.References" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Server.GoTo" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Widget.InteractiveGoal" -> "Lean.Server.FileWorker.RequestHandling";
  "Lean.Widget.Diff" -> "Lean.Server.FileWorker.RequestHandling";
  "Aesop.Builder.Basic" -> "Aesop.Builder.Cases";
  "Aesop.RuleTac.Cases" -> "Aesop.Builder.Cases";
  "Lean" -> "Qq.ForLean.ToExpr";
  "Lean" -> "Mathlib.Tactic.ClearExcept";
  "Lean.Meta.Basic" -> "Lean.Meta.Match.MatcherInfo";
  "Lean.MetavarContext" -> "Lean.Util.OccursCheck";
  "Lean.Data.Json.FromToJson" -> "Lean.Widget.TaggedText";
  "Lean.Server.Rpc.Basic" -> "Lean.Widget.TaggedText";
  "Lean.Meta.DiscrTree" -> "Mathlib.Lean.Meta.DiscrTree";
  "Mathlib.Lean.Expr.Traverse" -> "Mathlib.Lean.Meta.DiscrTree";
  "Lean.Data.RBMap" -> "Lean.Data.RBTree";
  "Lean.Meta.CollectFVars" -> "Lean.Meta.Tactic.Cleanup";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Cleanup";
  "Lean.Util.SCC" -> "Lean.Elab.PreDefinition.Main";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.Main";
  "Lean.Elab.PreDefinition.Structural" -> "Lean.Elab.PreDefinition.Main";
  "Lean.Elab.PreDefinition.WF.Main" -> "Lean.Elab.PreDefinition.Main";
  "Lean.Elab.PreDefinition.MkInhabitant" -> "Lean.Elab.PreDefinition.Main";
  "Lean.Runtime" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.NameMangling" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.ExportAttr" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.InitAttr" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.IR.EmitUtil" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.IR.NormIds" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.IR.SimpCase" -> "Lean.Compiler.IR.EmitC";
  "Lean.Compiler.IR.Boxing" -> "Lean.Compiler.IR.EmitC";
  "Lean.Elab.Tactic.Simp" -> "Lean.Elab.Tactic.Conv.Pattern";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Pattern";
  "Lean.HeadIndex" -> "Lean.Elab.Tactic.Conv.Pattern";
  "Lean.Widget.InteractiveCode" -> "Lean.Widget";
  "Lean.Widget.InteractiveDiagnostic" -> "Lean.Widget";
  "Lean.Widget.InteractiveGoal" -> "Lean.Widget";
  "Lean.Widget.TaggedText" -> "Lean.Widget";
  "Lean.Widget.UserWidget" -> "Lean.Widget";
  "Lean.Data.Options" -> "Aesop.Check";
  "Init.Tactics" -> "Init.SizeOf";
  "Mathlib.Tactic.TryThis" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Util.Pickle" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Tactic.Cache" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Tactic.Core" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Tactic.SolveByElim" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Data.ListM.Heartbeats" -> "Mathlib.Tactic.LibrarySearch";
  "Mathlib.Control.Basic" -> "Mathlib.Tactic.LibrarySearch";
  "Init.WF" -> "Init.Data.Nat.Div";
  "Init.WFTactics" -> "Init.Data.Nat.Div";
  "Init.Data.Nat.Basic" -> "Init.Data.Nat.Div";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Data.Prod";
  "Mathlib.Util.CompileInductive" -> "Mathlib.Init.Data.Prod";
  "Init.System.IO" -> "Lean.Data.Json.Stream";
  "Lean.Data.Json.Parser" -> "Lean.Data.Json.Stream";
  "Lean.Data.Json.Printer" -> "Lean.Data.Json.Stream";
  "Lean.Data.Json.FromToJson" -> "Lean.Data.Json.Stream";
  "Aesop.Index" -> "Aesop.Rule";
  "Aesop.Rule.Basic" -> "Aesop.Rule";
  "Aesop.Percent" -> "Aesop.Rule";
  "Aesop.Util" -> "Aesop.Rule";
  "Lean.Parser.Term" -> "Lean.Parser.Do";
  "Lean.Compiler.InlineAttrs" -> "Lean.Compiler";
  "Lean.Compiler.Specialize" -> "Lean.Compiler";
  "Lean.Compiler.ConstFolding" -> "Lean.Compiler";
  "Lean.Compiler.ClosedTermCache" -> "Lean.Compiler";
  "Lean.Compiler.ExternAttr" -> "Lean.Compiler";
  "Lean.Compiler.ImplementedByAttr" -> "Lean.Compiler";
  "Lean.Compiler.NeverExtractAttr" -> "Lean.Compiler";
  "Lean.Compiler.IR" -> "Lean.Compiler";
  "Lean.Compiler.CSimpAttr" -> "Lean.Compiler";
  "Lean.Compiler.FFI" -> "Lean.Compiler";
  "Lean.Compiler.NoncomputableAttr" -> "Lean.Compiler";
  "Lean.Compiler.Main" -> "Lean.Compiler";
  "Lean.Compiler.AtMostOnce" -> "Lean.Compiler";
  "Lean.Compiler.Old" -> "Lean.Compiler";
  "Lean.Meta.Tactic.Assumption" -> "Std.Tactic.Simpa";
  "Lean.Elab.Tactic.Simp" -> "Std.Tactic.Simpa";
  "Lean.Linter.Util" -> "Std.Tactic.Simpa";
  "Std.Lean.Meta.LCtx" -> "Std.Tactic.Simpa";
  "Std.Lean.Parser" -> "Std.Tactic.Simpa";
  "Std.Tactic.OpenPrivate" -> "Std.Tactic.Simpa";
  "Lean.Elab.Command" -> "Lean.Elab.GenInjective";
  "Lean.Meta.Injective" -> "Lean.Elab.GenInjective";
  "Lean.Elab.Command" -> "Lean.Elab.Syntax";
  "Lean.Parser.Syntax" -> "Lean.Elab.Syntax";
  "Lean.Elab.Util" -> "Lean.Elab.Syntax";
  "Lean.Environment" -> "Lean.Eval";
  "Lean.Compiler.LCNF.MonoTypes" -> "Lean.Compiler.LCNF.ToMono";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.ToMono";
  "Lean.Util.CollectFVars" -> "Lean.Elab.Tactic.Induction";
  "Lean.AuxRecursor" -> "Lean.Elab.Tactic.Induction";
  "Lean.Parser.Term" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.RecursorInfo" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.CollectMVars" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.Tactic.ElimInfo" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.Tactic.Induction" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.Tactic.Cases" -> "Lean.Elab.Tactic.Induction";
  "Lean.Meta.GeneralizeVars" -> "Lean.Elab.Tactic.Induction";
  "Lean.Elab.App" -> "Lean.Elab.Tactic.Induction";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Induction";
  "Lean.Elab.Tactic.Generalize" -> "Lean.Elab.Tactic.Induction";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Util.Imports";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.NormIds";
  "Lean" -> "Mathlib.Tactic.DeriveToExpr";
  "Mathlib.Tactic.ToLevel" -> "Mathlib.Tactic.DeriveToExpr";
  "Lean.Util.ForEachExprWhere" -> "Lean.Elab.Inductive";
  "Lean.Util.ReplaceLevel" -> "Lean.Elab.Inductive";
  "Lean.Util.ReplaceExpr" -> "Lean.Elab.Inductive";
  "Lean.Util.CollectLevelParams" -> "Lean.Elab.Inductive";
  "Lean.Meta.Constructions" -> "Lean.Elab.Inductive";
  "Lean.Meta.CollectFVars" -> "Lean.Elab.Inductive";
  "Lean.Meta.SizeOf" -> "Lean.Elab.Inductive";
  "Lean.Meta.Injective" -> "Lean.Elab.Inductive";
  "Lean.Meta.IndPredBelow" -> "Lean.Elab.Inductive";
  "Lean.Elab.Command" -> "Lean.Elab.Inductive";
  "Lean.Elab.ComputedFields" -> "Lean.Elab.Inductive";
  "Lean.Elab.DefView" -> "Lean.Elab.Inductive";
  "Lean.Elab.DeclUtil" -> "Lean.Elab.Inductive";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Inductive";
  "Lean.Server.CodeActions" -> "Std.Tactic.TryThis";
  "Lean.Widget.UserWidget" -> "Std.Tactic.TryThis";
  "Std.Lean.Name" -> "Std.Tactic.TryThis";
  "Std.Lean.Format" -> "Std.Tactic.TryThis";
  "Std.Lean.Position" -> "Std.Tactic.TryThis";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.Check";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Check";
  "Lean.Compiler.LCNF.CompatibleTypes" -> "Lean.Compiler.LCNF.Check";
  "Aesop.Constants" -> "Aesop.Tree.UnsafeQueue";
  "Aesop.Rule" -> "Aesop.Tree.UnsafeQueue";
  "Std.Data.Array.Merge" -> "Aesop.Tree.UnsafeQueue";
  "Lean.Meta.Basic" -> "Mathlib.Tactic.Backtracking";
  "Lean.Meta.Tactic.Util" -> "Mathlib.Tactic.Backtracking";
  "Mathlib.Control.Basic" -> "Mathlib.Tactic.Backtracking";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.Backtracking";
  "Mathlib.Data.Sum.Basic" -> "Mathlib.Tactic.Backtracking";
  "Init.Data.Format.Basic" -> "Init.Data.Repr";
  "Init.Data.Int.Basic" -> "Init.Data.Repr";
  "Init.Data.Nat.Div" -> "Init.Data.Repr";
  "Init.Data.UInt.Basic" -> "Init.Data.Repr";
  "Init.Control.Id" -> "Init.Data.Repr";
  "Lean.Expr" -> "Lean.Meta.ForEachExpr";
  "Lean.Util.MonadCache" -> "Lean.Meta.ForEachExpr";
  "Lean.Meta.Basic" -> "Lean.Meta.ForEachExpr";
  "Lean.Data.HashMap" -> "Lean.Util.MonadCache";
  "Lean.Server.Rpc.Basic" -> "Lean.Server.Rpc";
  "Lean.Server.Rpc.Deriving" -> "Lean.Server.Rpc";
  "Lean.Server.Rpc.RequestHandling" -> "Lean.Server.Rpc";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Subst";
  "Lean.Meta.Tactic.FVarSubst" -> "Lean.Meta.Tactic.Subst";
  "Lean.Compiler.ImplementedByAttr" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Renaming" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.ElimDead" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.AlphaEqv" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Bind" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Simp.JpCases" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Simp.DiscrM" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Simp.FunDeclInfo" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Compiler.LCNF.Simp.Config" -> "Lean.Compiler.LCNF.Simp.SimpM";
  "Lean.Elab.Attributes" -> "Lean.Elab.Mixfix";
  "Lean.Elab.Tactic.Rewrite" -> "Mathlib.Tactic.NthRewrite";
  "Lean.Elab.BuiltinTerm" -> "Mathlib.Tactic.NthRewrite";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Cache";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.ElimDeadVars";
  "Lean.Compiler.IR.FreeVars" -> "Lean.Compiler.IR.ElimDeadVars";
  "Lean.Meta.Tactic.Simp.SimpTheorems" -> "Lean.Linter.MissingDocs";
  "Lean.Elab.Command" -> "Lean.Linter.MissingDocs";
  "Lean.Elab.SetOption" -> "Lean.Linter.MissingDocs";
  "Lean.Linter.Util" -> "Lean.Linter.MissingDocs";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.Nonempty";
  "Mathlib.Init.ZeroOne" -> "Mathlib.Algebra.Group.Defs";
  "Mathlib.Init.Data.Int.Basic" -> "Mathlib.Algebra.Group.Defs";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Algebra.Group.Defs";
  "Mathlib.Tactic.Common" -> "Mathlib.Algebra.Group.Defs";
  "Mathlib.Logic.IsEmpty" -> "Mathlib.Logic.Unique";
  "Mathlib.Init.Logic" -> "Mathlib.Logic.Unique";
  "Mathlib.Init.Data.Fin.Basic" -> "Mathlib.Logic.Unique";
  "Mathlib.Tactic.Common" -> "Mathlib.Logic.Unique";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Data.String.Defs" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Data.Array.Defs" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Data.KVMap" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Lean.Expr.ReplaceRec" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Lean.EnvExtension" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Lean.Meta.Simp" -> "Mathlib.Tactic.ToAdditive";
  "Std.Lean.NameMapAttribute" -> "Mathlib.Tactic.ToAdditive";
  "Std.Data.Option.Basic" -> "Mathlib.Tactic.ToAdditive";
  "Std.Tactic.CoeExt" -> "Mathlib.Tactic.ToAdditive";
  "Std.Tactic.Ext.Attr" -> "Mathlib.Tactic.ToAdditive";
  "Std.Tactic.Lint" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Tactic.Relation.Symm" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Tactic.Relation.Trans" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Tactic.Eqns" -> "Mathlib.Tactic.ToAdditive";
  "Mathlib.Tactic.Simps.Basic" -> "Mathlib.Tactic.ToAdditive";
  "Std.Lean.Meta.Basic" -> "Std.Lean.Meta.SavedState";
  "Std.Lean.MonadBacktrack" -> "Std.Lean.Meta.SavedState";
  "Lean.Meta.GlobalInstances" -> "Lean.Meta.GetConst";
  "Aesop.Check" -> "Aesop.Options.Internal";
  "Aesop.Options.Public" -> "Aesop.Options.Internal";
  "Lean.Meta.Tactic.Rewrite" -> "Lean.Elab.Tactic.Conv.Rewrite";
  "Lean.Elab.Tactic.Rewrite" -> "Lean.Elab.Tactic.Conv.Rewrite";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv.Rewrite";
  "Init.Control.Lawful" -> "Init.Control.ExceptCps";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Extra";
  "Lean.Server.Rpc.Basic" -> "Lean.Data.Lsp.Extra";
  "Lean.Parser.Module" -> "Lean.Elab.ParseImportsFast";
  "Lean.Elab.Syntax" -> "Lean.Elab.MacroRules";
  "Lean.Elab.AuxDef" -> "Lean.Elab.MacroRules";
  "Lean.MonadEnv" -> "Lean.DeclarationRange";
  "Lean.AuxRecursor" -> "Lean.DeclarationRange";
  "Lean.ToExpr" -> "Lean.DeclarationRange";
  "Lean.Meta.KAbstract" -> "Lean.Meta.GeneralizeTelescope";
  "Lean.Meta.Check" -> "Lean.Meta.GeneralizeTelescope";
  "Lean.Attributes" -> "Lean.ParserCompiler.Attribute";
  "Lean.Compiler.InitAttr" -> "Lean.ParserCompiler.Attribute";
  "Lean.ToExpr" -> "Lean.ParserCompiler.Attribute";
  "Lean.Meta.Basic" -> "Lean.Meta.Eqns";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Eqns";
  "Std.Data.Array.Init.Basic" -> "Std.Data.Array.Basic";
  "Std.Data.Ord" -> "Std.Data.Array.Basic";
  "Lean.Elab.Tactic.Conv.Basic" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Congr" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Rewrite" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Change" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Simp" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Pattern" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Delta" -> "Lean.Elab.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Unfold" -> "Lean.Elab.Tactic.Conv";
  "Mathlib.Init.Logic" -> "Mathlib.Logic.Basic";
  "Mathlib.Init.Function" -> "Mathlib.Logic.Basic";
  "Mathlib.Init.Algebra.Classes" -> "Mathlib.Logic.Basic";
  "Mathlib.Tactic.Basic" -> "Mathlib.Logic.Basic";
  "Mathlib.Tactic.LeftRight" -> "Mathlib.Logic.Basic";
  "Std.Util.LibraryNote" -> "Mathlib.Logic.Basic";
  "Std.Tactic.Lint.Basic" -> "Mathlib.Logic.Basic";
  "Aesop.Rule" -> "Aesop.Builder.Basic";
  "Lean.Elab.ElabRules" -> "Std.Tactic.SimpTrace";
  "Lean.Elab.Tactic.Simp" -> "Std.Tactic.SimpTrace";
  "Std.Lean.Parser" -> "Std.Tactic.SimpTrace";
  "Std.Tactic.TryThis" -> "Std.Tactic.SimpTrace";
  "Lean.Meta.TransparencyMode" -> "Aesop.Options.Public";
  "Init.Core" -> "Init.Classical";
  "Init.NotationExtra" -> "Init.Classical";
  "Lean.Data.PersistentHashMap" -> "Std.Lean.PersistentHashMap";
  "Aesop.Tree.Traversal" -> "Aesop.Tree.State";
  "Std.Classes.Order" -> "Std.Data.RBMap.Basic";
  "Std.Control.ForInStep.Basic" -> "Std.Data.RBMap.Basic";
  "Std.Logic" -> "Std.Data.RBMap.Basic";
  "Std.Tactic.HaveI" -> "Std.Data.RBMap.Basic";
  "Lean.Elab.Tactic.Induction" -> "Std.Tactic.RCases";
  "Mathlib.Util.Tactic" -> "Mathlib.Tactic.Choose";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Tactic.Choose";
  "Aesop.BuiltinRules.Assumption" -> "Aesop.BuiltinRules";
  "Aesop.BuiltinRules.ApplyHyps" -> "Aesop.BuiltinRules";
  "Aesop.BuiltinRules.DestructProducts" -> "Aesop.BuiltinRules";
  "Aesop.BuiltinRules.Intros" -> "Aesop.BuiltinRules";
  "Aesop.BuiltinRules.Split" -> "Aesop.BuiltinRules";
  "Aesop.BuiltinRules.Subst" -> "Aesop.BuiltinRules";
  "Aesop.Frontend" -> "Aesop.BuiltinRules";
  "Lean.Meta.Basic" -> "Lean.Meta.GeneralizeVars";
  "Lean.Util.CollectFVars" -> "Lean.Meta.GeneralizeVars";
  "Lean.Data.AssocList" -> "Lean.Data";
  "Lean.Data.Format" -> "Lean.Data";
  "Lean.Data.HashMap" -> "Lean.Data";
  "Lean.Data.HashSet" -> "Lean.Data";
  "Lean.Data.Json" -> "Lean.Data";
  "Lean.Data.JsonRpc" -> "Lean.Data";
  "Lean.Data.KVMap" -> "Lean.Data";
  "Lean.Data.LBool" -> "Lean.Data";
  "Lean.Data.LOption" -> "Lean.Data";
  "Lean.Data.Lsp" -> "Lean.Data";
  "Lean.Data.Name" -> "Lean.Data";
  "Lean.Data.NameMap" -> "Lean.Data";
  "Lean.Data.Occurrences" -> "Lean.Data";
  "Lean.Data.OpenDecl" -> "Lean.Data";
  "Lean.Data.Options" -> "Lean.Data";
  "Lean.Data.Parsec" -> "Lean.Data";
  "Lean.Data.PersistentArray" -> "Lean.Data";
  "Lean.Data.PersistentHashMap" -> "Lean.Data";
  "Lean.Data.PersistentHashSet" -> "Lean.Data";
  "Lean.Data.Position" -> "Lean.Data";
  "Lean.Data.PrefixTree" -> "Lean.Data";
  "Lean.Data.SMap" -> "Lean.Data";
  "Lean.Data.Trie" -> "Lean.Data";
  "Lean.Data.Xml" -> "Lean.Data";
  "Lean.Data.NameTrie" -> "Lean.Data";
  "Lean.Data.RBTree" -> "Lean.Data";
  "Lean.Data.RBMap" -> "Lean.Data";
  "Lean.Data.Rat" -> "Lean.Data";
  "Lean.Structure" -> "Lean.Meta.Structure";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Structure";
  "Lean.Expr" -> "Lean.Declaration";
  "Std.Tactic.RCases" -> "Std.Tactic.Ext.Attr";
  "Std.Lean.Command" -> "Std.Tactic.Ext.Attr";
  "Lean.Data.LBool" -> "Lean.Meta.InferType";
  "Lean.Meta.Basic" -> "Lean.Meta.InferType";
  "Aesop.Builder.Basic" -> "Aesop.Builder.Forward";
  "Lean.Class" -> "Lean.Elab.Structure";
  "Lean.Parser.Command" -> "Lean.Elab.Structure";
  "Lean.Meta.Closure" -> "Lean.Elab.Structure";
  "Lean.Meta.SizeOf" -> "Lean.Elab.Structure";
  "Lean.Meta.Injective" -> "Lean.Elab.Structure";
  "Lean.Meta.Structure" -> "Lean.Elab.Structure";
  "Lean.Meta.AppBuilder" -> "Lean.Elab.Structure";
  "Lean.Elab.Command" -> "Lean.Elab.Structure";
  "Lean.Elab.DeclModifiers" -> "Lean.Elab.Structure";
  "Lean.Elab.DeclUtil" -> "Lean.Elab.Structure";
  "Lean.Elab.Inductive" -> "Lean.Elab.Structure";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab.Structure";
  "Lean.Elab.Binders" -> "Lean.Elab.Structure";
  "Mathlib.Init.Data.Bool.Basic" -> "Mathlib.Init.Data.Bool.Lemmas";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Data.Bool.Lemmas";
  "Mathlib.Tactic.Coe" -> "Mathlib.Init.Data.Bool.Lemmas";
  "Lean.ProjFns" -> "Lean.Compiler.LCNF.ToLCNF";
  "Lean.Compiler.BorrowedAnnotation" -> "Lean.Compiler.LCNF.ToLCNF";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.ToLCNF";
  "Lean.Compiler.LCNF.Bind" -> "Lean.Compiler.LCNF.ToLCNF";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.ToLCNF";
  "Lean.Compiler.LCNF.Util" -> "Lean.Compiler.LCNF.ToLCNF";
  "Aesop.Options.Internal" -> "Aesop.Options";
  "Aesop.Options.Public" -> "Aesop.Options";
  "Lean.Environment" -> "Lean.Compiler.Old";
  "Lean.Data.Options" -> "Lean.PrettyPrinter.Delaborator.Options";
  "Lean.Data.RBTree" -> "Lean.Data.Json.Basic";
  "Lean.Elab.Command" -> "Std.Tactic.PrintDependents";
  "Lean.Util.FoldConsts" -> "Std.Tactic.PrintDependents";
  "Std.Lean.Delaborator" -> "Std.Tactic.PrintDependents";
  "Lean" -> "Mathlib.Tactic.Set";
  "Lean.Meta.Basic" -> "Lean.Meta.FunInfo";
  "Lean.Meta.InferType" -> "Lean.Meta.FunInfo";
  "Std.Tactic.Lint.Basic" -> "Std.Tactic.Lint.TypeClass";
  "Std.Data.Array.Basic" -> "Std.Tactic.Lint.TypeClass";
  "Lean" -> "Mathlib.Tactic.ToLevel";
  "Mathlib.Init.Align" -> "Mathlib.Tactic.ToLevel";
  "Aesop.Index.Basic" -> "Aesop.Index";
  "Aesop.Tracing" -> "Aesop.Index";
  "Std.Lean.Meta.InstantiateMVars" -> "Aesop.Index";
  "Init.Meta" -> "Init.Data.ToString.Macro";
  "Init.Data.ToString.Basic" -> "Init.Data.ToString.Macro";
  "Lean.AuxRecursor" -> "Lean.Meta.RecursorInfo";
  "Lean.Util.FindExpr" -> "Lean.Meta.RecursorInfo";
  "Lean.Meta.Basic" -> "Lean.Meta.RecursorInfo";
  "Lean.Elab.Command" -> "Std.Tactic.GuardExpr";
  "Lean.Elab.Tactic.Conv.Basic" -> "Std.Tactic.GuardExpr";
  "Lean.Meta.Basic" -> "Std.Tactic.GuardExpr";
  "Lean.Meta.Eval" -> "Std.Tactic.GuardExpr";
  "Std.Util.TermUnsafe" -> "Std.Tactic.GuardExpr";
  "Lean.Data.HashSet" -> "Std.Lean.HashSet";
  "Init.Control" -> "Lean.Data.JsonRpc";
  "Init.System.IO" -> "Lean.Data.JsonRpc";
  "Lean.Data.RBTree" -> "Lean.Data.JsonRpc";
  "Lean.Data.Json" -> "Lean.Data.JsonRpc";
  "Init.Data.String.Basic" -> "Init.Data.String";
  "Init.Data.String.Extra" -> "Init.Data.String";
  "Std.Classes.Dvd" -> "Std.Data.Int.Basic";
  "Lean.Meta.Tactic.LinearArith.Nat.Basic" -> "Lean.Meta.Tactic.LinearArith.Nat.Simp";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.ScopeM";
  "Aesop.Builder.Basic" -> "Aesop.Builder.NormSimp";
  "Lean.Meta.Basic" -> "Lean.Meta.ExprLens";
  "Lean.SubExpr" -> "Lean.Meta.ExprLens";
  "Aesop.Frontend.ElabM" -> "Aesop.Frontend.RuleExpr";
  "Aesop.Percent" -> "Aesop.Frontend.RuleExpr";
  "Aesop.Rule.Name" -> "Aesop.Frontend.RuleExpr";
  "Aesop.Builder" -> "Aesop.Frontend.RuleExpr";
  "Aesop.RuleSet" -> "Aesop.Frontend.RuleExpr";
  "Init.Data.Option.Basic" -> "Init.Control.Option";
  "Init.Control.Basic" -> "Init.Control.Option";
  "Init.Control.Except" -> "Init.Control.Option";
  "Lean" -> "Mathlib.Tactic.LabelAttr";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Lean.Message" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Data.KVMap" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Tactic.Simps.NotationClass" -> "Mathlib.Tactic.Simps.Basic";
  "Std.Classes.Dvd" -> "Mathlib.Tactic.Simps.Basic";
  "Std.Data.String.Basic" -> "Mathlib.Tactic.Simps.Basic";
  "Std.Util.LibraryNote" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Tactic.RunCmd" -> "Mathlib.Tactic.Simps.Basic";
  "Mathlib.Lean.Linter" -> "Mathlib.Tactic.Simps.Basic";
  "Lean.Meta" -> "Std.Lean.Meta.Inaccessible";
  "Lean.Compiler.InitAttr" -> "Lean.KeyedDeclsAttribute";
  "Lean.ScopedEnvExtension" -> "Lean.KeyedDeclsAttribute";
  "Lean.Compiler.IR.CompilerM" -> "Lean.KeyedDeclsAttribute";
  "Mathlib.Tactic.Attr.Register" -> "Mathlib.Tactic.Attr.Core";
  "Std.Logic" -> "Mathlib.Tactic.Attr.Core";
  "Lean" -> "Mathlib.Tactic.Use";
  "Std.Logic" -> "Mathlib.Tactic.Use";
  "Lean.Data.Name" -> "Lean.Compiler.NameMangling";
  "Lean.Expr" -> "Lean.Util.ReplaceExpr";
  "Aesop.Check" -> "Aesop.Search.Main";
  "Aesop.Frontend.Attribute" -> "Aesop.Search.Main";
  "Aesop.Options" -> "Aesop.Search.Main";
  "Aesop.RuleSet" -> "Aesop.Search.Main";
  "Aesop.Search.Expansion" -> "Aesop.Search.Main";
  "Aesop.Search.ExpandSafePrefix" -> "Aesop.Search.Main";
  "Aesop.Search.Queue" -> "Aesop.Search.Main";
  "Aesop.Tree" -> "Aesop.Search.Main";
  "Aesop.Util" -> "Aesop.Search.Main";
  "Lean.Elab.Tactic.Basic" -> "Mathlib.Tactic.TypeCheck";
  "Lean.Elab.Command" -> "Std.Tactic.OpenPrivate";
  "Lean.Util.FoldConsts" -> "Std.Tactic.OpenPrivate";
  "Lean.Parser.Module" -> "Std.Tactic.OpenPrivate";
  "Lean.Util.FoldConsts" -> "Lean.Elab.Print";
  "Lean.Elab.Command" -> "Lean.Elab.Print";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.DestructProducts";
  "Lean.Environment" -> "Lean.Compiler.IR.CompilerM";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.CompilerM";
  "Lean.Compiler.IR.Format" -> "Lean.Compiler.IR.CompilerM";
  "Std.Control.ForInStep.Basic" -> "Std.Control.ForInStep.Lemmas";
  "Std.Tactic.TryThis" -> "Mathlib.Tactic.TryThis";
  "Lean.Meta.Tactic.Util" -> "Mathlib.Tactic.TryThis";
  "Mathlib.Tactic.Basic" -> "Mathlib.Tactic.ExtractLets";
  "Lean.InternalExceptionId" -> "Lean.Elab.Exception";
  "Lean.Meta.Basic" -> "Lean.Elab.Exception";
  "Std.Tactic.Ext" -> "Mathlib.Init.Logic";
  "Std.Tactic.Lint.Basic" -> "Mathlib.Init.Logic";
  "Std.Logic" -> "Mathlib.Init.Logic";
  "Std.WF" -> "Mathlib.Init.Logic";
  "Mathlib.Tactic.Alias" -> "Mathlib.Init.Logic";
  "Mathlib.Tactic.Basic" -> "Mathlib.Init.Logic";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Init.Logic";
  "Mathlib.Tactic.Relation.Symm" -> "Mathlib.Init.Logic";
  "Mathlib.Mathport.Attributes" -> "Mathlib.Init.Logic";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Logic";
  "Mathlib.Tactic.Relation.Trans" -> "Mathlib.Init.Logic";
  "Lean.Environment" -> "Lean.ScopedEnvExtension";
  "Lean.Data.NameTrie" -> "Lean.ScopedEnvExtension";
  "Lean.Attributes" -> "Lean.ScopedEnvExtension";
  "Lean.Parser.Command" -> "Lean.Elab.PreDefinition.WF.TerminationHint";
  "Lean.Data.Options" -> "Lean.Util.Profile";
  "Aesop.Constants" -> "Aesop.Tree.Data";
  "Aesop.Script" -> "Aesop.Tree.Data";
  "Aesop.Tracing" -> "Aesop.Tree.Data";
  "Aesop.Tree.UnsafeQueue" -> "Aesop.Tree.Data";
  "Aesop.RuleTac.Basic" -> "Aesop.RuleTac.Tactic";
  "Lean.Meta.Eval" -> "Lean.Elab.Eval";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Eval";
  "Lean" -> "Mathlib.Tactic.LeftRight";
  "Lean.Meta.Tactic.AC.Main" -> "Lean.Meta.Tactic.AC";
  "Init.Data.Int.Basic" -> "Init.Data.Int";
  "Lean.Util.ForEachExprWhere" -> "Lean.Meta.Tactic.Util";
  "Lean.Meta.Basic" -> "Lean.Meta.Tactic.Util";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Util";
  "Lean.Meta.PPGoal" -> "Lean.Meta.Tactic.Util";
  "Std.Util.ExtendedBinder" -> "Std.Classes.SetNotation";
  "Init.Data.Array.Basic" -> "Init.Data.Array.DecidableEq";
  "Init.Classical" -> "Init.Data.Array.DecidableEq";
  "Mathlib.Lean.Meta" -> "Mathlib.Lean.Elab.Tactic.Basic";
  "Lean.Expr" -> "Lean.Util.FindMVar";
  "Init.Control.Basic" -> "Init.Control.Reader";
  "Init.Control.Id" -> "Init.Control.Reader";
  "Init.Control.Except" -> "Init.Control.Reader";
  "Lean.Data.Lsp.Capabilities" -> "Lean.Data.Lsp.InitShutdown";
  "Lean.Data.Lsp.Workspace" -> "Lean.Data.Lsp.InitShutdown";
  "Lean.Data.Json" -> "Lean.Data.Lsp.InitShutdown";
  "Lean.Data.Trie" -> "Lean.Parser.Types";
  "Lean.Syntax" -> "Lean.Parser.Types";
  "Lean.Message" -> "Lean.Parser.Types";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp.DefaultAlt";
  "Lean.Elab.Attributes" -> "Lean.Elab.LetRec";
  "Lean.Elab.Binders" -> "Lean.Elab.LetRec";
  "Lean.Elab.DeclModifiers" -> "Lean.Elab.LetRec";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.LetRec";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab.LetRec";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.AlphaEqv";
  "Lean.Attributes" -> "Mathlib.Mathport.Attributes";
  "Lean.Util.HasConstCache" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Lean.Meta.CasesOn" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Lean.Meta.Match.Match" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Lean.Elab.RecAppSyntax" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.BRecOn";
  "Aesop.Tree" -> "Aesop.Search.Queue.Class";
  "Lean.Compiler.LCNF.ReduceJpArity" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Renaming" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.Basic" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.FunDeclInfo" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.JpCases" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.Config" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.InlineCandidate" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.Main" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.InlineProj" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.DefaultAlt" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.SimpValue" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Compiler.LCNF.Simp.Used" -> "Lean.Compiler.LCNF.Simp";
  "Lean.Expr" -> "Lean.Meta.Match.Value";
  "Init.Data.Nat.Basic" -> "Init.System.Platform";
  "Lean" -> "Mathlib.Tactic.Substs";
  "Std.Tactic.Simpa" -> "Mathlib.Tactic.Core";
  "Mathlib.Lean.Expr" -> "Mathlib.Tactic.Core";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.BaseTypes";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.BaseTypes";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp.InlineCandidate";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.Bind";
  "Lean.Expr" -> "Std.Lean.Meta.Expr";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Util.Tactic";
  "Init.Core" -> "Init.Data.Option.Basic";
  "Init.Control.Basic" -> "Init.Data.Option.Basic";
  "Init.Coe" -> "Init.Data.Option.Basic";
  "Lean.Parser.Extra" -> "Lean.Parser.Level";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.Intros";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Rewrite";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Rewrite";
  "Lean.Meta.KAbstract" -> "Lean.Meta.Tactic.Rewrite";
  "Lean.Meta.Check" -> "Lean.Meta.Tactic.Rewrite";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Rewrite";
  "Aesop.Search.Expansion.Simp.Basic" -> "Aesop.Search.Expansion.Simp";
  "Aesop.Search.Expansion.Simp.SimpAll" -> "Aesop.Search.Expansion.Simp";
  "Aesop.Search.Expansion.Simp.SimpGoal" -> "Aesop.Search.Expansion.Simp";
  "Lean.Elab.Import" -> "Lean.Elab";
  "Lean.Elab.Exception" -> "Lean.Elab";
  "Lean.Elab.Config" -> "Lean.Elab";
  "Lean.Elab.Command" -> "Lean.Elab";
  "Lean.Elab.Term" -> "Lean.Elab";
  "Lean.Elab.App" -> "Lean.Elab";
  "Lean.Elab.Binders" -> "Lean.Elab";
  "Lean.Elab.LetRec" -> "Lean.Elab";
  "Lean.Elab.Frontend" -> "Lean.Elab";
  "Lean.Elab.BuiltinNotation" -> "Lean.Elab";
  "Lean.Elab.Declaration" -> "Lean.Elab";
  "Lean.Elab.Tactic" -> "Lean.Elab";
  "Lean.Elab.Match" -> "Lean.Elab";
  "Lean.Elab.Quotation" -> "Lean.Elab";
  "Lean.Elab.Syntax" -> "Lean.Elab";
  "Lean.Elab.Do" -> "Lean.Elab";
  "Lean.Elab.StructInst" -> "Lean.Elab";
  "Lean.Elab.Inductive" -> "Lean.Elab";
  "Lean.Elab.Structure" -> "Lean.Elab";
  "Lean.Elab.Print" -> "Lean.Elab";
  "Lean.Elab.MutualDef" -> "Lean.Elab";
  "Lean.Elab.AuxDef" -> "Lean.Elab";
  "Lean.Elab.PreDefinition" -> "Lean.Elab";
  "Lean.Elab.Deriving" -> "Lean.Elab";
  "Lean.Elab.DeclarationRange" -> "Lean.Elab";
  "Lean.Elab.Extra" -> "Lean.Elab";
  "Lean.Elab.GenInjective" -> "Lean.Elab";
  "Lean.Elab.BuiltinTerm" -> "Lean.Elab";
  "Lean.Elab.Arg" -> "Lean.Elab";
  "Lean.Elab.PatternVar" -> "Lean.Elab";
  "Lean.Elab.ElabRules" -> "Lean.Elab";
  "Lean.Elab.Macro" -> "Lean.Elab";
  "Lean.Elab.Notation" -> "Lean.Elab";
  "Lean.Elab.Mixfix" -> "Lean.Elab";
  "Lean.Elab.MacroRules" -> "Lean.Elab";
  "Lean.Elab.BuiltinCommand" -> "Lean.Elab";
  "Lean.Elab.RecAppSyntax" -> "Lean.Elab";
  "Lean.Elab.Eval" -> "Lean.Elab";
  "Lean.Elab.Calc" -> "Lean.Elab";
  "Lean.Elab.InheritDoc" -> "Lean.Elab";
  "Lean.Elab.ParseImportsFast" -> "Lean.Elab";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Data.Sum.Basic";
  "Lean.Meta.Basic" -> "Lean.Meta.ExprTraverse";
  "Lean.SubExpr" -> "Lean.Meta.ExprTraverse";
  "Lean" -> "Mathlib.Tactic.WLOG";
  "Mathlib.Tactic.Core" -> "Mathlib.Tactic.WLOG";
  "Init.SimpLemmas" -> "Init.Data.Prod";
  "Mathlib.Tactic.Basic" -> "Mathlib.Tactic.Existsi";
  "Lean.Expr" -> "Lean.Compiler.ConstFolding";
  "Std.Data.Nat.Gcd" -> "Std.Data.Rat.Basic";
  "Std.Data.Int.DivMod" -> "Std.Data.Rat.Basic";
  "Std.Tactic.Ext" -> "Std.Data.Rat.Basic";
  "Lean.Data.JsonRpc" -> "Lean.Data.Lsp.Capabilities";
  "Lean.Data.Lsp.TextSync" -> "Lean.Data.Lsp.Capabilities";
  "Lean.Data.Lsp.LanguageFeatures" -> "Lean.Data.Lsp.Capabilities";
  "Lean.Data.Lsp.CodeActions" -> "Lean.Data.Lsp.Capabilities";
  "Std.Data.Nat.Lemmas" -> "Std.Data.Array.Merge";
  "Std.Data.Ord" -> "Std.Data.Array.Merge";
  "Lean.Data.Format" -> "Lean.Data.Position";
  "Lean.ToExpr" -> "Lean.Data.Position";
  "Lean" -> "Mathlib.Lean.Expr.Basic";
  "Std.Lean.Expr" -> "Mathlib.Lean.Expr.Basic";
  "Std.Data.List.Basic" -> "Mathlib.Lean.Expr.Basic";
  "Aesop.Frontend" -> "Aesop.BuiltinRules.Split";
  "Aesop.Check" -> "Aesop.Tree.AddRapp";
  "Aesop.RuleTac.RuleApplicationWithMVarInfo" -> "Aesop.Tree.AddRapp";
  "Aesop.Tree.Traversal" -> "Aesop.Tree.AddRapp";
  "Aesop.Tree.TreeM" -> "Aesop.Tree.AddRapp";
  "Lean.Data.Json" -> "Lean.Data.Lsp.Diagnostics";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.Diagnostics";
  "Lean.Data.Lsp.Utf16" -> "Lean.Data.Lsp.Diagnostics";
  "Lean.Message" -> "Lean.Data.Lsp.Diagnostics";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Location";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Location";
  "Aesop.Builder.Apply" -> "Aesop.Builder";
  "Aesop.Builder.Basic" -> "Aesop.Builder";
  "Aesop.Builder.Cases" -> "Aesop.Builder";
  "Aesop.Builder.Constructors" -> "Aesop.Builder";
  "Aesop.Builder.Default" -> "Aesop.Builder";
  "Aesop.Builder.Forward" -> "Aesop.Builder";
  "Aesop.Builder.NormSimp" -> "Aesop.Builder";
  "Aesop.Builder.Tactic" -> "Aesop.Builder";
  "Aesop.Builder.Unfold" -> "Aesop.Builder";
  "Lean.Environment" -> "Lean.ProjFns";
  "Lean.Data.AssocList" -> "Lean.Meta.Tactic.FVarSubst";
  "Lean.Expr" -> "Lean.Meta.Tactic.FVarSubst";
  "Lean.LocalContext" -> "Lean.Meta.Tactic.FVarSubst";
  "Lean.Util.ReplaceExpr" -> "Lean.Meta.Tactic.FVarSubst";
  "Lean.PrettyPrinter.Delaborator.Builtins" -> "Std.Tactic.CoeExt";
  "Std.Lean.Delaborator" -> "Std.Tactic.CoeExt";
  "Lean.DeclarationRange" -> "Lean.DocString";
  "Lean.MonadEnv" -> "Lean.DocString";
  "Lean.Elab.Eval" -> "Lean.Widget.UserWidget";
  "Lean.Server.Rpc.RequestHandling" -> "Lean.Widget.UserWidget";
  "Lean.Data.LOption" -> "Lean.Meta.Basic";
  "Lean.Environment" -> "Lean.Meta.Basic";
  "Lean.Class" -> "Lean.Meta.Basic";
  "Lean.ReducibilityAttrs" -> "Lean.Meta.Basic";
  "Lean.Util.ReplaceExpr" -> "Lean.Meta.Basic";
  "Lean.Util.MonadBacktrack" -> "Lean.Meta.Basic";
  "Lean.Compiler.InlineAttrs" -> "Lean.Meta.Basic";
  "Lean.Meta.TransparencyMode" -> "Lean.Meta.Basic";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.SizeOf";
  "Lean.Meta.Instances" -> "Lean.Meta.SizeOf";
  "Mathlib.Tactic.Basic" -> "Mathlib.Tactic.RSuffices";
  "Lean.Elab.ElabRules" -> "Std.Tactic.ShowTerm";
  "Std.Tactic.TryThis" -> "Std.Tactic.ShowTerm";
  "Lean.Runtime" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.ClosedTermCache" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.ExternAttr" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.IR.FreeVars" -> "Lean.Compiler.IR.Boxing";
  "Lean.Compiler.IR.ElimDeadVars" -> "Lean.Compiler.IR.Boxing";
  "Lean.Data" -> "Lean";
  "Lean.Compiler" -> "Lean";
  "Lean.Environment" -> "Lean";
  "Lean.Modifiers" -> "Lean";
  "Lean.ProjFns" -> "Lean";
  "Lean.Runtime" -> "Lean";
  "Lean.ResolveName" -> "Lean";
  "Lean.Attributes" -> "Lean";
  "Lean.Parser" -> "Lean";
  "Lean.ReducibilityAttrs" -> "Lean";
  "Lean.Elab" -> "Lean";
  "Lean.Class" -> "Lean";
  "Lean.LocalContext" -> "Lean";
  "Lean.MetavarContext" -> "Lean";
  "Lean.AuxRecursor" -> "Lean";
  "Lean.Meta" -> "Lean";
  "Lean.Util" -> "Lean";
  "Lean.Eval" -> "Lean";
  "Lean.Structure" -> "Lean";
  "Lean.PrettyPrinter" -> "Lean";
  "Lean.CoreM" -> "Lean";
  "Lean.InternalExceptionId" -> "Lean";
  "Lean.Server" -> "Lean";
  "Lean.ScopedEnvExtension" -> "Lean";
  "Lean.DocString" -> "Lean";
  "Lean.DeclarationRange" -> "Lean";
  "Lean.LazyInitExtension" -> "Lean";
  "Lean.LoadDynlib" -> "Lean";
  "Lean.Widget" -> "Lean";
  "Lean.Log" -> "Lean";
  "Lean.Linter" -> "Lean";
  "Lean.SubExpr" -> "Lean";
  "Lean.Data.HashMap" -> "Lean.Util.SCC";
  "Lean" -> "Mathlib.Util.WhatsNew";
  "Std.Util.TermUnsafe" -> "Mathlib.Util.WhatsNew";
  "Std.Tactic.OpenPrivate" -> "Mathlib.Util.WhatsNew";
  "Lean.Meta.Eqns" -> "Mathlib.Tactic.Eqns";
  "Mathlib.Lean.Expr" -> "Mathlib.Tactic.Eqns";
  "Std.Lean.NameMapAttribute" -> "Mathlib.Tactic.Eqns";
  "Mathlib.Util.Pickle" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Data.ListM.Heartbeats" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Lean.Meta.DiscrTree" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Tactic.Cache" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Tactic.SolveByElim" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Tactic.TryThis" -> "Mathlib.Tactic.Rewrites";
  "Mathlib.Control.Basic" -> "Mathlib.Tactic.Rewrites";
  "Lean.Parser.Term" -> "Lean.Elab.BindersUtil";
  "Lean.Meta.Transform" -> "Lean.Elab.Deriving.DecEq";
  "Lean.Meta.Inductive" -> "Lean.Elab.Deriving.DecEq";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.DecEq";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.DecEq";
  "Lean.Compiler.LCNF.BaseTypes" -> "Lean.Compiler.LCNF.OtherDecl";
  "Lean.Compiler.LCNF.MonoTypes" -> "Lean.Compiler.LCNF.OtherDecl";
  "Lean.Elab.Command" -> "Lean.Linter.UnusedVariables";
  "Lean.Util.ForEachExprWhere" -> "Lean.Linter.UnusedVariables";
  "Lean.Linter.Util" -> "Lean.Linter.UnusedVariables";
  "Lean.Server.References" -> "Lean.Linter.UnusedVariables";
  "Lean" -> "Mathlib.Tactic.GuardGoalNums";
  "Std.Tactic.NoMatch" -> "Std.Data.Array.Init.Basic";
  "Std.Data.List.Init.Lemmas" -> "Std.Data.Array.Init.Basic";
  "Lean" -> "Mathlib.Tactic.RenameBVar";
  "Mathlib.Util.Tactic" -> "Mathlib.Tactic.RenameBVar";
  "Mathlib.Tactic.Cases" -> "Mathlib.Tactic.Lift";
  "Mathlib.Tactic.PermuteGoals" -> "Mathlib.Tactic.Lift";
  "Mathlib.Init.Data.Int.Order" -> "Mathlib.Tactic.Lift";
  "Lean.Meta.Basic" -> "Mathlib.Lean.Meta.Basic";
  "Lean.Expr" -> "Lean.Compiler.BorrowedAnnotation";
  "Aesop.Options" -> "Aesop.Search.Expansion.Simp.Basic";
  "Aesop.Script" -> "Aesop.Search.Expansion.Simp.Basic";
  "Aesop.RuleSet" -> "Aesop.Search.Expansion.Simp.Basic";
  "Mathlib.Data.FunLike.Embedding" -> "Mathlib.Data.FunLike.Equiv";
  "Aesop.Search.Expansion.Simp.Basic" -> "Aesop.Search.Expansion.Simp.SimpAll";
  "Lean.PrettyPrinter" -> "Lean.Server.InfoUtils";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp.SimpValue";
  "Lean.Elab.Command" -> "Std.Linter.UnnecessarySeqFocus";
  "Lean.Linter.Util" -> "Std.Linter.UnnecessarySeqFocus";
  "Std.Lean.AttributeExtra" -> "Std.Linter.UnnecessarySeqFocus";
  "Std.Lean.Command" -> "Std.Linter.UnnecessarySeqFocus";
  "Lean.Meta" -> "Std.Lean.Meta.Basic";
  "Lean.Meta.Tactic.LinearArith.Solver" -> "Lean.Meta.Tactic.LinearArith";
  "Lean.Meta.Tactic.LinearArith.Nat" -> "Lean.Meta.Tactic.LinearArith";
  "Lean.Meta.Tactic.LinearArith.Main" -> "Lean.Meta.Tactic.LinearArith";
  "Lean.Meta.Tactic.LinearArith.Simp" -> "Lean.Meta.Tactic.LinearArith";
  "Lean.Elab.ElabRules" -> "Std.Util.LibraryNote";
  "Lean.Data.HashSet" -> "Lean.Data.NameMap";
  "Lean.Data.RBMap" -> "Lean.Data.NameMap";
  "Lean.Data.RBTree" -> "Lean.Data.NameMap";
  "Lean.Data.SSet" -> "Lean.Data.NameMap";
  "Lean.Data.Name" -> "Lean.Data.NameMap";
  "Std.Tactic.OpenPrivate" -> "Std.Tactic.NoMatch";
  "Lean.Elab.Match" -> "Std.Tactic.NoMatch";
  "Lean.Elab.ElabRules" -> "Std.Tactic.NoMatch";
  "Lean" -> "Mathlib.Tactic.Recover";
  "Std.Tactic.RCases" -> "Mathlib.Tactic.Recover";
  "Mathlib.Tactic.Cache" -> "Mathlib.Tactic.Recover";
  "Qq.Macro" -> "Qq";
  "Qq.Delab" -> "Qq";
  "Qq.MetaM" -> "Qq";
  "Qq.Match" -> "Qq";
  "Qq.AssertInstancesCommute" -> "Qq";
  "Lean.Meta.WHNF" -> "Lean.Meta.DiscrTree";
  "Lean.Meta.Transform" -> "Lean.Meta.DiscrTree";
  "Lean.Meta.DiscrTreeTypes" -> "Lean.Meta.DiscrTree";
  "Lean.Meta.PPGoal" -> "Lean.Elab.InfoTree.Main";
  "Std.Data.Ord" -> "Std.Classes.Order";
  "Std.Tactic.Simpa" -> "Std.Classes.Order";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.FindRecArg" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.Preprocess" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.BRecOn" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.IndPred" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.Eqns" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Lean.Elab.PreDefinition.Structural.SmartUnfolding" -> "Lean.Elab.PreDefinition.Structural.Main";
  "Aesop.Search.Expansion" -> "Aesop.Search.ExpandSafePrefix";
  "Lean.Data.Xml.Basic" -> "Lean.Data.Xml";
  "Lean.Data.Xml.Parser" -> "Lean.Data.Xml";
  "Lean.Parser.Term" -> "Mathlib.Init.Set";
  "Std.Classes.SetNotation" -> "Mathlib.Init.Set";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Set";
  "Lean.Elab.Term" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Induction" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Generalize" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Injection" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Match" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Rewrite" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Location" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Simp" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.BuiltinTactic" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Split" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Conv" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Delta" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Meta" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Unfold" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Cache" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Calc" -> "Lean.Elab.Tactic";
  "Lean.Elab.Tactic.Congr" -> "Lean.Elab.Tactic";
  "Init.Coe" -> "Init.Data.Int.Basic";
  "Init.Data.Nat.Div" -> "Init.Data.Int.Basic";
  "Init.Data.List.Basic" -> "Init.Data.Int.Basic";
  "Lean.Environment" -> "Lean.Compiler.NoncomputableAttr";
  "Lean.CoreM" -> "Lean.Compiler.LCNF.CompilerM";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.CompilerM";
  "Lean.Compiler.LCNF.LCtx" -> "Lean.Compiler.LCNF.CompilerM";
  "Lean.Compiler.LCNF.ConfigOptions" -> "Lean.Compiler.LCNF.CompilerM";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.DeclHash";
  "Init.Prelude" -> "Init.Notation";
  "Init.Coe" -> "Init.Notation";
  "Lean.Meta.Tactic.LinearArith.Nat.Basic" -> "Lean.Meta.Tactic.LinearArith.Nat";
  "Lean.Meta.Tactic.LinearArith.Nat.Simp" -> "Lean.Meta.Tactic.LinearArith.Nat";
  "Lean.Meta.Tactic.LinearArith.Nat.Solver" -> "Lean.Meta.Tactic.LinearArith.Nat";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Revert";
  "Std.Tactic.RCases" -> "Std.Data.Char";
  "Lean.Elab.App" -> "Lean.Elab.Extra";
  "Lean.Elab.BuiltinNotation" -> "Lean.Elab.Extra";
  "Lean.Meta.Check" -> "Lean.Meta.Eval";
  "Lean.Data.Json" -> "Lean.Util.Paths";
  "Lean.Util.Path" -> "Lean.Util.Paths";
  "Lean.Meta.Tactic.Congr" -> "Std.Tactic.Congr";
  "Std.Tactic.RCases" -> "Std.Tactic.Congr";
  "Std.Tactic.Ext" -> "Std.Tactic.Congr";
  "Lean.CoreM" -> "Lean.Attributes";
  "Lean.MonadEnv" -> "Lean.Attributes";
  "Lean.Meta.Basic" -> "Lean.Meta.Tactic.AuxLemma";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.Instances";
  "Lean.Meta.GlobalInstances" -> "Lean.Meta.Instances";
  "Lean.Meta.DiscrTree" -> "Lean.Meta.Instances";
  "Lean.Meta.CollectMVars" -> "Lean.Meta.Instances";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Algebra.Order";
  "Mathlib.Init.Algebra.Classes" -> "Mathlib.Init.Algebra.Order";
  "Mathlib.Init.Data.Ordering.Basic" -> "Mathlib.Init.Algebra.Order";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Init.Algebra.Order";
  "Mathlib.Tactic.SplitIfs" -> "Mathlib.Init.Algebra.Order";
  "Init.Control.Except" -> "Init.Data.String.Extra";
  "Init.Data.ByteArray" -> "Init.Data.String.Extra";
  "Init.SimpLemmas" -> "Init.Data.String.Extra";
  "Init.Data.Nat.Linear" -> "Init.Data.String.Extra";
  "Init.Util" -> "Init.Data.String.Extra";
  "Init.WFTactics" -> "Init.Data.String.Extra";
  "Lean.Compiler.LCNF.AlphaEqv" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Bind" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Check" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.CSE" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.DependsOn" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ElimDead" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.FixedParams" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.JoinPoints" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.LCtx" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Level" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Main" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Passes" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.PullFunDecls" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.PullLetDecls" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ReduceJpArity" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Simp" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Specialize" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.SpecInfo" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Testing" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ToDecl" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ToExpr" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ToLCNF" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Util" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ConfigOptions" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ForEachExpr" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.MonoTypes" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ToMono" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.MonadScope" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.Closure" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.LambdaLifting" -> "Lean.Compiler.LCNF";
  "Lean.Compiler.LCNF.ReduceArity" -> "Lean.Compiler.LCNF";
  "Lean.Util.FindExpr" -> "Lean.Util.Sorry";
  "Lean.Declaration" -> "Lean.Util.Sorry";
  "Std.Data.Fin.Basic" -> "Std.Data.Fin.Lemmas";
  "Std.Data.Nat.Lemmas" -> "Std.Data.Fin.Lemmas";
  "Std.Tactic.Ext" -> "Std.Data.Fin.Lemmas";
  "Std.Tactic.Simpa" -> "Std.Data.Fin.Lemmas";
  "Std.Tactic.NormCast.Lemmas" -> "Std.Data.Fin.Lemmas";
  "Aesop.Options" -> "Aesop.Search.Queue";
  "Aesop.Tracing" -> "Aesop.Search.Queue";
  "Aesop.Tree" -> "Aesop.Search.Queue";
  "Aesop.Search.Queue.Class" -> "Aesop.Search.Queue";
  "Std.Data.BinomialHeap" -> "Aesop.Search.Queue";
  "Aesop.Builder.Apply" -> "Aesop.Builder.Constructors";
  "Init.Prelude" -> "Init.Coe";
  "Init.Control.EState" -> "Init.System.IO";
  "Init.Control.Reader" -> "Init.System.IO";
  "Init.Data.String" -> "Init.System.IO";
  "Init.Data.ByteArray" -> "Init.System.IO";
  "Init.System.IOError" -> "Init.System.IO";
  "Init.System.FilePath" -> "Init.System.IO";
  "Init.System.ST" -> "Init.System.IO";
  "Init.Data.ToString.Macro" -> "Init.System.IO";
  "Init.Data.Ord" -> "Init.System.IO";
  "Std.Data.Option.Init.Lemmas" -> "Std.Data.Option.Lemmas";
  "Std.Data.Option.Basic" -> "Std.Data.Option.Lemmas";
  "Std.Tactic.Ext.Attr" -> "Std.Data.Option.Lemmas";
  "Std.Logic" -> "Std.Data.Option.Lemmas";
  "Lean" -> "Mathlib.Tactic.SudoSetOption";
  "Lean.Data.RBMap" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Meta.SynthInstance" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Util.FindMVar" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Util.FindLevelMVar" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Util.CollectLevelParams" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Util.ReplaceLevel" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.PrettyPrinter.Delaborator.Options" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.PrettyPrinter.Delaborator.SubExpr" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Elab.Config" -> "Lean.PrettyPrinter.Delaborator.TopDownAnalyze";
  "Lean.Elab.Command" -> "Std.Tactic.Where";
  "Aesop.Util" -> "Aesop.Frontend.ElabM";
  "Lean.Elab.MacroArgUtil" -> "Lean.Elab.ElabRules";
  "Lean.Elab.AuxDef" -> "Lean.Elab.ElabRules";
  "Lean.Meta.Tactic.Congr" -> "Lean.Elab.Tactic.Congr";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Congr";
  "Lean" -> "Mathlib.Lean.EnvExtension";
  "Lean" -> "Mathlib.Tactic.PushNeg";
  "Mathlib.Lean.Expr" -> "Mathlib.Tactic.PushNeg";
  "Mathlib.Logic.Basic" -> "Mathlib.Tactic.PushNeg";
  "Mathlib.Init.Algebra.Order" -> "Mathlib.Tactic.PushNeg";
  "Mathlib.Tactic.Conv" -> "Mathlib.Tactic.PushNeg";
  "Lean" -> "Mathlib.Tactic.Alias";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.CongrTheorems";
  "Lean.Class" -> "Lean.Meta.CongrTheorems";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.Propose";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.Propose";
  "Mathlib.Lean.Meta.Basic" -> "Mathlib.Tactic.Propose";
  "Mathlib.Lean.Meta.DiscrTree" -> "Mathlib.Tactic.Propose";
  "Mathlib.Tactic.Cache" -> "Mathlib.Tactic.Propose";
  "Mathlib.Tactic.Core" -> "Mathlib.Tactic.Propose";
  "Mathlib.Tactic.SolveByElim" -> "Mathlib.Tactic.Propose";
  "Mathlib.Tactic.TryThis" -> "Mathlib.Tactic.Propose";
  "Lean.Meta.Tactic.Simp.SimpTheorems" -> "Lean.Meta.Tactic.Simp";
  "Lean.Meta.Tactic.Simp.SimpCongrTheorems" -> "Lean.Meta.Tactic.Simp";
  "Lean.Meta.Tactic.Simp.Types" -> "Lean.Meta.Tactic.Simp";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.Simp";
  "Lean.Meta.Tactic.Simp.Rewrite" -> "Lean.Meta.Tactic.Simp";
  "Lean.Meta.Tactic.Simp.SimpAll" -> "Lean.Meta.Tactic.Simp";
  "Lean" -> "Mathlib.Tactic.FailIfNoProgress";
  "Lean.Data.Parsec" -> "Lean.Data.Xml.Parser";
  "Lean.Data.Xml.Basic" -> "Lean.Data.Xml.Parser";
  "Lean.Meta.Tactic.Apply" -> "Mathlib.Lean.LocalContext";
  "Lean.Data.PersistentHashMap" -> "Lean.Data.PersistentHashSet";
  "Lean.Meta.Basic" -> "Lean.Meta.AbstractMVars";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Logic.IsEmpty";
  "Std.Data.Int.Lemmas" -> "Std.Data.Rat.Lemmas";
  "Std.Data.Rat.Basic" -> "Std.Data.Rat.Lemmas";
  "Lean.Compiler.IR.CompilerM" -> "Lean.Compiler.IR.Sorry";
  "Aesop.RuleSet" -> "Aesop.Frontend.Extension.Init";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.Structural.SmartUnfolding";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.SmartUnfolding";
  "Lean.Expr" -> "Lean.Util.CollectFVars";
  "Lean.LocalContext" -> "Lean.Util.CollectFVars";
  "Lean.Meta.Closure" -> "Lean.Meta.AbstractNestedProofs";
  "Mathlib.Init.Algebra.Order" -> "Mathlib.Init.Algebra.Functions";
  "Lean.Meta.Reduce" -> "Lean.Meta.Tactic.Refl";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Refl";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Refl";
  "Aesop.Util.Basic" -> "Aesop.Util.UnorderedArraySet";
  "Lean.Server.CodeActions" -> "Std.CodeAction.Attr";
  "Std.Util.TermUnsafe" -> "Std.CodeAction.Attr";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.CSE";
  "Lean.Compiler.LCNF.ToExpr" -> "Lean.Compiler.LCNF.CSE";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.CSE";
  "Lean.Elab.Tactic.Unfold" -> "Lean.Elab.Tactic.Conv.Unfold";
  "Lean.Elab.Tactic.Conv.Simp" -> "Lean.Elab.Tactic.Conv.Unfold";
  "Init.Data.String.Basic" -> "Init.Data.ToString.Basic";
  "Init.Data.UInt.Basic" -> "Init.Data.ToString.Basic";
  "Init.Data.Nat.Div" -> "Init.Data.ToString.Basic";
  "Init.Data.Repr" -> "Init.Data.ToString.Basic";
  "Init.Data.Int.Basic" -> "Init.Data.ToString.Basic";
  "Init.Data.Format.Basic" -> "Init.Data.ToString.Basic";
  "Init.Control.Id" -> "Init.Data.ToString.Basic";
  "Init.Control.Option" -> "Init.Data.ToString.Basic";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.FreeVars";
  "Lean.Data.Json" -> "Lean.Data.Lsp.LanguageFeatures";
  "Lean.Data.Lsp.Basic" -> "Lean.Data.Lsp.LanguageFeatures";
  "Aesop" -> "Mathlib.Tactic.Common";
  "Qq" -> "Mathlib.Tactic.Common";
  "Mathlib.Mathport.Rename" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Alias" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ApplyCongr" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ApplyWith" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Basic" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ByContra" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Cases" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.CasesM" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Choose" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Classical" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Clear_" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Clear!" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ClearExcept" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Coe" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Congr!" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Constructor" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Contrapose" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Conv" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Convert" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.DeriveToExpr" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Eqns" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Existsi" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ExtractLets" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.FailIfNoProgress" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Find" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.GeneralizeProofs" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.GuardGoalNums" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.GuardHypNums" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Have" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.HelpCmd" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.HigherOrder" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.InferParam" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Inhabit" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.IrreducibleDef" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.LabelAttr" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.LeftRight" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.LibrarySearch" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Lift" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Lint" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.MkIffOfInductiveProp" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.NthRewrite" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.PermuteGoals" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.PrintPrefix" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ProjectionNotation" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Propose" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.PushNeg" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Recover" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Rename" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.RenameBVar" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Relation.Symm" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Relation.Trans" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Replace" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Rewrites" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.RSuffices" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.RunCmd" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Says" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ScopedNS" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Set" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SimpIntro" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SimpRw" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Simps.Basic" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SolveByElim" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SplitIfs" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Spread" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Substs" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SuccessIfFailWithMsg" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SudoSetOption" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SwapVar" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.SplitIfs" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Tauto" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ToExpr" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.ToLevel" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Trace" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.TryThis" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.TypeCheck" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.UnsetOption" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Use" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Variable" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.WLOG" -> "Mathlib.Tactic.Common";
  "Mathlib.Util.CountHeartbeats" -> "Mathlib.Tactic.Common";
  "Mathlib.Util.Imports" -> "Mathlib.Tactic.Common";
  "Mathlib.Util.WhatsNew" -> "Mathlib.Tactic.Common";
  "Mathlib.Tactic.Conv" -> "Mathlib.Tactic.ApplyCongr";
  "Std.Tactic.OpenPrivate" -> "Mathlib.Tactic.ApplyCongr";
  "Mathlib.Logic.Basic" -> "Mathlib.Logic.Relator";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.PullLetDecls";
  "Lean.Compiler.LCNF.DependsOn" -> "Lean.Compiler.LCNF.PullLetDecls";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.PullLetDecls";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.PullLetDecls";
  "Lean" -> "Mathlib.Tactic.GuardHypNums";
  "Init.Coe" -> "Init.Data.Nat.Linear";
  "Init.Classical" -> "Init.Data.Nat.Linear";
  "Init.SimpLemmas" -> "Init.Data.Nat.Linear";
  "Init.Data.Nat.Basic" -> "Init.Data.Nat.Linear";
  "Init.Data.List.Basic" -> "Init.Data.Nat.Linear";
  "Init.Data.Prod" -> "Init.Data.Nat.Linear";
  "Init.Data.Array.Basic" -> "Init.Data.Array.Subarray";
  "Lean.Data.HashSet" -> "Lean.Util.ShareCommon";
  "Lean.Data.HashMap" -> "Lean.Util.ShareCommon";
  "Lean.Data.PersistentHashMap" -> "Lean.Util.ShareCommon";
  "Lean.Data.PersistentHashSet" -> "Lean.Util.ShareCommon";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.FindRecArg";
  "Lean.Linter.Basic" -> "Lean.Linter.Deprecated";
  "Lean.Attributes" -> "Lean.Linter.Deprecated";
  "Lean.Elab.InfoTree.Main" -> "Lean.Linter.Deprecated";
  "Lean" -> "Mathlib.Tactic.ByContra";
  "Mathlib.Tactic.PushNeg" -> "Mathlib.Tactic.ByContra";
  "Std.Data.List.Basic" -> "Std.Data.AssocList";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.UnificationHint";
  "Lean.Util.Recognizers" -> "Lean.Meta.UnificationHint";
  "Lean.Meta.DiscrTree" -> "Lean.Meta.UnificationHint";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.UnificationHint";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.FixedParams";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.FixedParams";
  "Lean.Elab.Command" -> "Mathlib.Tactic.PrintPrefix";
  "Lean.Expr" -> "Lean.Util.CollectLevelParams";
  "Lean.Meta.Tactic.Injection" -> "Lean.Elab.Tactic.Injection";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Elab.Tactic.Injection";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.Injection";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.PullFunDecls";
  "Lean.Compiler.LCNF.DependsOn" -> "Lean.Compiler.LCNF.PullFunDecls";
  "Lean.Compiler.LCNF.PassManager" -> "Lean.Compiler.LCNF.PullFunDecls";
  "Lean.Meta.Basic" -> "Lean.PrettyPrinter.Delaborator.SubExpr";
  "Lean.SubExpr" -> "Lean.PrettyPrinter.Delaborator.SubExpr";
  "Lean.Data.RBMap" -> "Lean.PrettyPrinter.Delaborator.SubExpr";
  "Lean.Meta.Basic" -> "Lean.Meta.ACLt";
  "Lean.Meta.FunInfo" -> "Lean.Meta.ACLt";
  "Lean.Meta.DiscrTree" -> "Lean.Meta.ACLt";
  "Lean.Elab.Command" -> "Lean.Elab.AuxDef";
  "Aesop.Tracing" -> "Aesop.Tree.ExtractProof";
  "Aesop.Tree.Tracing" -> "Aesop.Tree.ExtractProof";
  "Aesop.Tree.TreeM" -> "Aesop.Tree.ExtractProof";
  "Lean.Data.Options" -> "Lean.Elab.AutoBound";
  "Lean.LocalContext" -> "Lean.Compiler.LCNF.LCtx";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.LCtx";
  "Std.Tactic.OpenPrivate" -> "Std.Lean.Format";
  "Lean.Elab.InfoTree.Main" -> "Lean.Compiler.InitAttr";
  "Lean.KeyedDeclsAttribute" -> "Lean.Elab.Quotation.Precheck";
  "Lean.Parser.Command" -> "Lean.Elab.Quotation.Precheck";
  "Lean.Elab.Term" -> "Lean.Elab.Quotation.Precheck";
  "Lean.Elab.Quotation.Util" -> "Lean.Elab.Quotation.Precheck";
  "Lean.Meta.PPGoal" -> "Lean.Widget.InteractiveGoal";
  "Lean.Widget.InteractiveCode" -> "Lean.Widget.InteractiveGoal";
  "Lean.Data.Lsp.Extra" -> "Lean.Widget.InteractiveGoal";
  "Lean.Environment" -> "Lean.Util.Recognizers";
  "Init.Data.Nat.Linear" -> "Init.Data.List.BasicAux";
  "Init.Data.List.Basic" -> "Init.Data.List.BasicAux";
  "Init.Util" -> "Init.Data.List.BasicAux";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Data.Ordering.Basic";
  "Lean" -> "Mathlib.Tactic.InferParam";
  "Mathlib.Lean.Expr.Basic" -> "Mathlib.Tactic.InferParam";
  "Lean.Elab.ElabRules" -> "Mathlib.Tactic.Classical";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.CompatibleTypes";
  "Aesop.Frontend.Attribute" -> "Aesop.Frontend.Command";
  "Lean.Elab.ElabRules" -> "Std.Tactic.SeqFocus";
  "Aesop.Search.SearchM" -> "Aesop.Search.RuleSelection";
  "Lean.Data.Position" -> "Lean.Elab.InfoTree.Types";
  "Lean.Data.OpenDecl" -> "Lean.Elab.InfoTree.Types";
  "Lean.MetavarContext" -> "Lean.Elab.InfoTree.Types";
  "Lean.Environment" -> "Lean.Elab.InfoTree.Types";
  "Lean.Data.Json" -> "Lean.Elab.InfoTree.Types";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Align";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Align";
  "Mathlib.Tactic.Relation.Rfl" -> "Mathlib.Init.Align";
  "Mathlib.Tactic.Relation.Symm" -> "Mathlib.Init.Align";
  "Mathlib.Tactic.Relation.Trans" -> "Mathlib.Init.Align";
  "Init.Meta" -> "Init.NotationExtra";
  "Init.Data.Array.Subarray" -> "Init.NotationExtra";
  "Init.Data.ToString" -> "Init.NotationExtra";
  "Lean.Util.RecDepth" -> "Lean.CoreM";
  "Lean.Util.Trace" -> "Lean.CoreM";
  "Lean.Log" -> "Lean.CoreM";
  "Lean.Eval" -> "Lean.CoreM";
  "Lean.ResolveName" -> "Lean.CoreM";
  "Lean.Elab.InfoTree.Types" -> "Lean.CoreM";
  "Lean.MonadEnv" -> "Lean.CoreM";
  "Lean.Data.Rat" -> "Lean.Meta.Tactic.LinearArith.Solver";
  "Lean.Meta.Tactic.Simp.Main" -> "Std.Tactic.Lint.Simp";
  "Std.Tactic.Lint.Basic" -> "Std.Tactic.Lint.Simp";
  "Std.Tactic.OpenPrivate" -> "Std.Tactic.Lint.Simp";
  "Std.Util.LibraryNote" -> "Std.Tactic.Lint.Simp";
  "Lean.Expr" -> "Lean.Compiler.LCNF.Basic";
  "Lean.Meta.Instances" -> "Lean.Compiler.LCNF.Basic";
  "Lean.Compiler.InlineAttrs" -> "Lean.Compiler.LCNF.Basic";
  "Lean.Compiler.Specialize" -> "Lean.Compiler.LCNF.Basic";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.Basic";
  "Lean.Parser.Types" -> "Lean.Parser.Basic";
  "Lean.Meta.Basic" -> "Lean.SubExpr";
  "Lean.Data.Json" -> "Lean.SubExpr";
  "Lean.Data.RBMap" -> "Lean.SubExpr";
  "Lean.Log" -> "Lean.Elab.Level";
  "Lean.Parser.Level" -> "Lean.Elab.Level";
  "Lean.Elab.Exception" -> "Lean.Elab.Level";
  "Lean.Elab.AutoBound" -> "Lean.Elab.Level";
  "Lean.Environment" -> "Lean.MonadEnv";
  "Lean.Exception" -> "Lean.MonadEnv";
  "Lean.Declaration" -> "Lean.MonadEnv";
  "Lean.Log" -> "Lean.MonadEnv";
  "Lean.AuxRecursor" -> "Lean.MonadEnv";
  "Lean.Compiler.Old" -> "Lean.MonadEnv";
  "Std.Data.BinomialHeap.Basic" -> "Std.Data.BinomialHeap.Lemmas";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.Util.Recognizers" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.Meta.DiscrTree" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.Meta.Eqns" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.Meta.Tactic.AuxLemma" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.DocString" -> "Lean.Meta.Tactic.Simp.SimpTheorems";
  "Lean.MetavarContext" -> "Lean.Meta.Closure";
  "Lean.Environment" -> "Lean.Meta.Closure";
  "Lean.Util.FoldConsts" -> "Lean.Meta.Closure";
  "Lean.Meta.Basic" -> "Lean.Meta.Closure";
  "Lean.Meta.Check" -> "Lean.Meta.Closure";
  "Lean" -> "Mathlib.Tactic.Inhabit";
  "Lean.Compiler.ImplementedByAttr" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.ElimDead" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.AlphaEqv" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Bind" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.FunDeclInfo" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.InlineCandidate" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.InlineProj" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.Used" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.DefaultAlt" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.SimpValue" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Compiler.LCNF.Simp.ConstantFold" -> "Lean.Compiler.LCNF.Simp.Main";
  "Lean.Data.LBool" -> "Lean.Meta.Offset";
  "Lean.Meta.InferType" -> "Lean.Meta.Offset";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Offset";
  "Lean" -> "Mathlib.Lean.Meta.Simp";
  "Std.Tactic.OpenPrivate" -> "Mathlib.Lean.Meta.Simp";
  "Std.Data.String.Basic" -> "Std.Data.String";
  "Std.Data.String.Lemmas" -> "Std.Data.String";
  "Lean.PrettyPrinter.Delaborator.Basic" -> "Lean.PrettyPrinter.Delaborator.Builtins";
  "Lean.PrettyPrinter.Delaborator.SubExpr" -> "Lean.PrettyPrinter.Delaborator.Builtins";
  "Lean.PrettyPrinter.Delaborator.TopDownAnalyze" -> "Lean.PrettyPrinter.Delaborator.Builtins";
  "Lean.Parser" -> "Lean.PrettyPrinter.Delaborator.Builtins";
  "Lean.Meta.Check" -> "Lean.Meta.Tactic.Constructor";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Constructor";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Constructor";
  "Aesop.Search.SearchM" -> "Aesop.Search.Expansion.Basic";
  "Lean.Compiler.Specialize" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.Simp" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.SpecInfo" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.PrettyPrinter" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.ToExpr" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.Level" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.PhaseExt" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.MonadScope" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.Closure" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Compiler.LCNF.FVarUtil" -> "Lean.Compiler.LCNF.Specialize";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Contradiction" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Rewrite" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Generalize" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Replace" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Induction" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Cases" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.ElimInfo" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Delta" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Constructor" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Simp" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.AuxLemma" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.SplitIf" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Split" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Cleanup" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Unfold" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Rename" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.LinearArith" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.AC" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Refl" -> "Lean.Meta.Tactic";
  "Lean.Meta.Tactic.Congr" -> "Lean.Meta.Tactic";
  "Lean.Meta.Transform" -> "Lean.Elab.Deriving.Ord";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.Ord";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.Ord";
  "Lean.Server.Watchdog" -> "Lean.Server";
  "Lean.Server.FileWorker" -> "Lean.Server";
  "Lean.Server.Rpc" -> "Lean.Server";
  "Lean.Server.CodeActions" -> "Lean.Server";
  "Lean" -> "Mathlib.Tactic.IrreducibleDef";
  "Mathlib.Tactic.Eqns" -> "Mathlib.Tactic.IrreducibleDef";
  "Mathlib.Data.Subtype" -> "Mathlib.Tactic.IrreducibleDef";
  "Lean.Meta.Transform" -> "Lean.Elab.Deriving.BEq";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.BEq";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.BEq";
  "Lean" -> "Mathlib.Tactic.Have";
  "Mathlib.Data.Array.Defs" -> "Mathlib.Tactic.Have";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Meta.Tactic.Contradiction" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Meta.Tactic.Refl" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Elab.Binders" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Elab.Open" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Elab.SetOption" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Lean.Elab.Tactic.ElabTerm" -> "Lean.Elab.Tactic.BuiltinTactic";
  "Std.Data.Nat.Init.Lemmas" -> "Std.Data.Fin.Basic";
  "Lean.Meta.Basic" -> "Lean.Meta.Inductive";
  "Lean.Compiler.Specialize" -> "Lean.Compiler.LCNF.SpecInfo";
  "Lean.Compiler.LCNF.FixedParams" -> "Lean.Compiler.LCNF.SpecInfo";
  "Lean.Compiler.LCNF.InferType" -> "Lean.Compiler.LCNF.SpecInfo";
  "Lean.Meta.Basic" -> "Lean.Meta";
  "Lean.Meta.LevelDefEq" -> "Lean.Meta";
  "Lean.Meta.WHNF" -> "Lean.Meta";
  "Lean.Meta.InferType" -> "Lean.Meta";
  "Lean.Meta.FunInfo" -> "Lean.Meta";
  "Lean.Meta.ExprDefEq" -> "Lean.Meta";
  "Lean.Meta.DecLevel" -> "Lean.Meta";
  "Lean.Meta.DiscrTree" -> "Lean.Meta";
  "Lean.Meta.Reduce" -> "Lean.Meta";
  "Lean.Meta.Instances" -> "Lean.Meta";
  "Lean.Meta.AbstractMVars" -> "Lean.Meta";
  "Lean.Meta.SynthInstance" -> "Lean.Meta";
  "Lean.Meta.AppBuilder" -> "Lean.Meta";
  "Lean.Meta.Tactic" -> "Lean.Meta";
  "Lean.Meta.KAbstract" -> "Lean.Meta";
  "Lean.Meta.RecursorInfo" -> "Lean.Meta";
  "Lean.Meta.GeneralizeTelescope" -> "Lean.Meta";
  "Lean.Meta.Match" -> "Lean.Meta";
  "Lean.Meta.ReduceEval" -> "Lean.Meta";
  "Lean.Meta.Closure" -> "Lean.Meta";
  "Lean.Meta.AbstractNestedProofs" -> "Lean.Meta";
  "Lean.Meta.ForEachExpr" -> "Lean.Meta";
  "Lean.Meta.Transform" -> "Lean.Meta";
  "Lean.Meta.PPGoal" -> "Lean.Meta";
  "Lean.Meta.UnificationHint" -> "Lean.Meta";
  "Lean.Meta.Inductive" -> "Lean.Meta";
  "Lean.Meta.SizeOf" -> "Lean.Meta";
  "Lean.Meta.IndPredBelow" -> "Lean.Meta";
  "Lean.Meta.Coe" -> "Lean.Meta";
  "Lean.Meta.CollectFVars" -> "Lean.Meta";
  "Lean.Meta.GeneralizeVars" -> "Lean.Meta";
  "Lean.Meta.Injective" -> "Lean.Meta";
  "Lean.Meta.Structure" -> "Lean.Meta";
  "Lean.Meta.Constructions" -> "Lean.Meta";
  "Lean.Meta.CongrTheorems" -> "Lean.Meta";
  "Lean.Meta.Eqns" -> "Lean.Meta";
  "Lean.Meta.CasesOn" -> "Lean.Meta";
  "Lean.Meta.ExprLens" -> "Lean.Meta";
  "Lean.Meta.ExprTraverse" -> "Lean.Meta";
  "Lean.Meta.Eval" -> "Lean.Meta";
  "Lean.Meta.Eqns" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Util.CollectFVars" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Util.ForEachExprWhere" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Meta.Tactic.Split" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Meta.Tactic.Apply" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Meta.Tactic.Refl" -> "Lean.Elab.PreDefinition.Eqns";
  "Lean.Meta.Match.MatchEqs" -> "Lean.Elab.PreDefinition.Eqns";
  "Std.Data.AssocList" -> "Std.Data.HashMap.Basic";
  "Std.Data.Nat.Basic" -> "Std.Data.HashMap.Basic";
  "Std.Classes.BEq" -> "Std.Data.HashMap.Basic";
  "Lean.Meta.RecursorInfo" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.SynthInstance" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.Tactic.Util" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Induction";
  "Lean.Meta.Tactic.FVarSubst" -> "Lean.Meta.Tactic.Induction";
  "Mathlib.Algebra.Group.Defs" -> "Mathlib.Data.Nat.Cast.Defs";
  "Mathlib.Algebra.NeZero" -> "Mathlib.Data.Nat.Cast.Defs";
  "Lean.Data.Json" -> "Lean.Server.Rpc.Basic";
  "Lean.Meta.CongrTheorems" -> "Lean.Meta.Tactic.Congr";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic.Congr";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Congr";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Tactic.Congr";
  "Lean.Meta.Tactic.Refl" -> "Lean.Meta.Tactic.Congr";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Meta.Tactic.Congr";
  "Lean.Attributes" -> "Lean.Class";
  "Init.Control.Basic" -> "Init.Control.Except";
  "Init.Control.Id" -> "Init.Control.Except";
  "Init.Coe" -> "Init.Control.Except";
  "Lean.Elab.Syntax" -> "Lean.Elab.MacroArgUtil";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.PushProj";
  "Lean.Compiler.IR.FreeVars" -> "Lean.Compiler.IR.PushProj";
  "Lean.Compiler.IR.NormIds" -> "Lean.Compiler.IR.PushProj";
  "Lean" -> "Mathlib.Tactic.SimpIntro";
  "Std.Lean.Parser" -> "Mathlib.Tactic.SimpIntro";
  "Lean.Data.Name" -> "Lean.Util.Path";
  "Lean.Meta.Tactic.Util" -> "Lean.Elab.SyntheticMVars";
  "Lean.Util.ForEachExpr" -> "Lean.Elab.SyntheticMVars";
  "Lean.Util.OccursCheck" -> "Lean.Elab.SyntheticMVars";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.SyntheticMVars";
  "Lean.Meta.Basic" -> "Lean.Meta.Reduce";
  "Lean.Meta.FunInfo" -> "Lean.Meta.Reduce";
  "Lean.Util.MonadCache" -> "Lean.Meta.Reduce";
  "Aesop.Builder.Basic" -> "Aesop.Builder.Apply";
  "Std.Classes.BEq" -> "Std";
  "Std.Classes.Cast" -> "Std";
  "Std.Classes.Dvd" -> "Std";
  "Std.Classes.LawfulMonad" -> "Std";
  "Std.Classes.Order" -> "Std";
  "Std.Classes.RatCast" -> "Std";
  "Std.Classes.SetNotation" -> "Std";
  "Std.CodeAction" -> "Std";
  "Std.CodeAction.Attr" -> "Std";
  "Std.CodeAction.Basic" -> "Std";
  "Std.CodeAction.Misc" -> "Std";
  "Std.Control.ForInStep" -> "Std";
  "Std.Control.ForInStep.Basic" -> "Std";
  "Std.Control.ForInStep.Lemmas" -> "Std";
  "Std.Data.Array.Basic" -> "Std";
  "Std.Data.Array.Init.Basic" -> "Std";
  "Std.Data.Array.Init.Lemmas" -> "Std";
  "Std.Data.Array.Lemmas" -> "Std";
  "Std.Data.Array.Merge" -> "Std";
  "Std.Data.AssocList" -> "Std";
  "Std.Data.BinomialHeap" -> "Std";
  "Std.Data.BinomialHeap.Basic" -> "Std";
  "Std.Data.BinomialHeap.Lemmas" -> "Std";
  "Std.Data.Char" -> "Std";
  "Std.Data.DList" -> "Std";
  "Std.Data.Fin.Basic" -> "Std";
  "Std.Data.Fin.Lemmas" -> "Std";
  "Std.Data.HashMap" -> "Std";
  "Std.Data.HashMap.Basic" -> "Std";
  "Std.Data.HashMap.WF" -> "Std";
  "Std.Data.Int.Basic" -> "Std";
  "Std.Data.Int.DivMod" -> "Std";
  "Std.Data.Int.Lemmas" -> "Std";
  "Std.Data.List.Basic" -> "Std";
  "Std.Data.List.Init.Lemmas" -> "Std";
  "Std.Data.List.Lemmas" -> "Std";
  "Std.Data.Nat.Basic" -> "Std";
  "Std.Data.Nat.Gcd" -> "Std";
  "Std.Data.Nat.Init.Lemmas" -> "Std";
  "Std.Data.Nat.Lemmas" -> "Std";
  "Std.Data.Option.Basic" -> "Std";
  "Std.Data.Option.Init.Lemmas" -> "Std";
  "Std.Data.Option.Lemmas" -> "Std";
  "Std.Data.Ord" -> "Std";
  "Std.Data.PairingHeap" -> "Std";
  "Std.Data.Prod.Lex" -> "Std";
  "Std.Data.RBMap" -> "Std";
  "Std.Data.RBMap.Alter" -> "Std";
  "Std.Data.RBMap.Basic" -> "Std";
  "Std.Data.RBMap.Lemmas" -> "Std";
  "Std.Data.RBMap.WF" -> "Std";
  "Std.Data.Range.Lemmas" -> "Std";
  "Std.Data.Rat" -> "Std";
  "Std.Data.Rat.Basic" -> "Std";
  "Std.Data.Rat.Lemmas" -> "Std";
  "Std.Data.String" -> "Std";
  "Std.Data.String.Basic" -> "Std";
  "Std.Data.String.Lemmas" -> "Std";
  "Std.Lean.AttributeExtra" -> "Std";
  "Std.Lean.Command" -> "Std";
  "Std.Lean.Delaborator" -> "Std";
  "Std.Lean.Expr" -> "Std";
  "Std.Lean.Format" -> "Std";
  "Std.Lean.HashMap" -> "Std";
  "Std.Lean.HashSet" -> "Std";
  "Std.Lean.InfoTree" -> "Std";
  "Std.Lean.Meta.AssertHypotheses" -> "Std";
  "Std.Lean.Meta.Basic" -> "Std";
  "Std.Lean.Meta.Clear" -> "Std";
  "Std.Lean.Meta.DiscrTree" -> "Std";
  "Std.Lean.Meta.Expr" -> "Std";
  "Std.Lean.Meta.Inaccessible" -> "Std";
  "Std.Lean.Meta.InstantiateMVars" -> "Std";
  "Std.Lean.Meta.LCtx" -> "Std";
  "Std.Lean.Meta.SavedState" -> "Std";
  "Std.Lean.Meta.UnusedNames" -> "Std";
  "Std.Lean.MonadBacktrack" -> "Std";
  "Std.Lean.Name" -> "Std";
  "Std.Lean.NameMapAttribute" -> "Std";
  "Std.Lean.Parser" -> "Std";
  "Std.Lean.PersistentHashMap" -> "Std";
  "Std.Lean.PersistentHashSet" -> "Std";
  "Std.Lean.Position" -> "Std";
  "Std.Lean.Tactic" -> "Std";
  "Std.Lean.TagAttribute" -> "Std";
  "Std.Linter" -> "Std";
  "Std.Linter.UnnecessarySeqFocus" -> "Std";
  "Std.Linter.UnreachableTactic" -> "Std";
  "Std.Logic" -> "Std";
  "Std.Tactic.Basic" -> "Std";
  "Std.Tactic.ByCases" -> "Std";
  "Std.Tactic.CoeExt" -> "Std";
  "Std.Tactic.Congr" -> "Std";
  "Std.Tactic.Exact" -> "Std";
  "Std.Tactic.Ext" -> "Std";
  "Std.Tactic.Ext.Attr" -> "Std";
  "Std.Tactic.GuardExpr" -> "Std";
  "Std.Tactic.GuardMsgs" -> "Std";
  "Std.Tactic.HaveI" -> "Std";
  "Std.Tactic.Instances" -> "Std";
  "Std.Tactic.Lint" -> "Std";
  "Std.Tactic.Lint.Basic" -> "Std";
  "Std.Tactic.Lint.Frontend" -> "Std";
  "Std.Tactic.Lint.Misc" -> "Std";
  "Std.Tactic.Lint.Simp" -> "Std";
  "Std.Tactic.Lint.TypeClass" -> "Std";
  "Std.Tactic.NoMatch" -> "Std";
  "Std.Tactic.NormCast.Ext" -> "Std";
  "Std.Tactic.NormCast.Lemmas" -> "Std";
  "Std.Tactic.OpenPrivate" -> "Std";
  "Std.Tactic.PrintDependents" -> "Std";
  "Std.Tactic.RCases" -> "Std";
  "Std.Tactic.SeqFocus" -> "Std";
  "Std.Tactic.ShowTerm" -> "Std";
  "Std.Tactic.SimpTrace" -> "Std";
  "Std.Tactic.Simpa" -> "Std";
  "Std.Tactic.SqueezeScope" -> "Std";
  "Std.Tactic.TryThis" -> "Std";
  "Std.Tactic.Unreachable" -> "Std";
  "Std.Tactic.Where" -> "Std";
  "Std.Util.ExtendedBinder" -> "Std";
  "Std.Util.LibraryNote" -> "Std";
  "Std.Util.TermUnsafe" -> "Std";
  "Std.WF" -> "Std";
  "Std.Data.RBMap.Alter" -> "Std.Data.RBMap.Lemmas";
  "Std.Data.Nat.Lemmas" -> "Std.Data.RBMap.Lemmas";
  "Std.Data.List.Lemmas" -> "Std.Data.RBMap.Lemmas";
  "Aesop.Nanos" -> "Aesop.Util.Basic";
  "Aesop.Util.UnionFind" -> "Aesop.Util.Basic";
  "Std.Lean.Expr" -> "Aesop.Util.Basic";
  "Std.Lean.Meta.DiscrTree" -> "Aesop.Util.Basic";
  "Std.Lean.PersistentHashSet" -> "Aesop.Util.Basic";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Match.CaseArraySizes";
  "Lean.Meta.Match.CaseValues" -> "Lean.Meta.Match.CaseArraySizes";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Inhabited" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Nonempty" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.TypeName" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.BEq" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.DecEq" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Repr" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.FromToJson" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.SizeOf" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Hashable" -> "Lean.Elab.Deriving";
  "Lean.Elab.Deriving.Ord" -> "Lean.Elab.Deriving";
  "Lean.Meta.Eqns" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Meta.Tactic.Split" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Meta.Tactic.Apply" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Elab.PreDefinition.Eqns" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Elab.PreDefinition.Structural.Basic" -> "Lean.Elab.PreDefinition.Structural.Eqns";
  "Lean.Expr" -> "Lean.ToExpr";
  "Aesop.Util.Basic" -> "Aesop.Util.Tactic";
  "Std.Logic" -> "Std.Data.RBMap.WF";
  "Std.Data.RBMap.Basic" -> "Std.Data.RBMap.WF";
  "Lean.PrettyPrinter" -> "Lean.Compiler.LCNF.PrettyPrinter";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.PrettyPrinter";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.PrettyPrinter";
  "Lean.Meta.Transform" -> "Lean.Elab.Deriving.Repr";
  "Lean.Meta.Inductive" -> "Lean.Elab.Deriving.Repr";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.Repr";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.Repr";
  "Lean.Syntax" -> "Lean.Elab.Quotation";
  "Lean.ResolveName" -> "Lean.Elab.Quotation";
  "Lean.Elab.Term" -> "Lean.Elab.Quotation";
  "Lean.Elab.Quotation.Util" -> "Lean.Elab.Quotation";
  "Lean.Elab.Quotation.Precheck" -> "Lean.Elab.Quotation";
  "Lean.Elab.Syntax" -> "Lean.Elab.Quotation";
  "Lean.Parser.Syntax" -> "Lean.Elab.Quotation";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Init.Data.Fin.Basic";
  "Lean.Compiler.LCNF.Simp.SimpM" -> "Lean.Compiler.LCNF.Simp.Used";
  "Lean.Widget.Basic" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Widget.InteractiveCode" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Widget.InteractiveGoal" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Widget.InteractiveDiagnostic" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Server.Rpc.RequestHandling" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Server.FileWorker.RequestHandling" -> "Lean.Server.FileWorker.WidgetRequests";
  "Lean.Meta.MatchUtil" -> "Lean.Meta.Tactic.Contradiction";
  "Lean.Meta.Tactic.Assumption" -> "Lean.Meta.Tactic.Contradiction";
  "Lean.Meta.Tactic.Cases" -> "Lean.Meta.Tactic.Contradiction";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Contradiction";
  "Lean.Compiler.CSimpAttr" -> "Mathlib.Util.CompileInductive";
  "Lean.Elab.PreDefinition" -> "Mathlib.Util.CompileInductive";
  "Mathlib.Tactic.RunCmd" -> "Mathlib.Util.CompileInductive";
  "Lean.Util.Sorry" -> "Lean.Log";
  "Lean.Message" -> "Lean.Log";
  "Lean.Meta.Tactic.Injection" -> "Lean.Meta.Tactic.UnifyEq";
  "Lean.Elab.Command" -> "Mathlib.Tactic.Constructor";
  "Lean.Meta.Tactic.Constructor" -> "Mathlib.Tactic.Constructor";
  "Lean.Environment" -> "Lean.Modifiers";
  "Lean.Elab.Open" -> "Lean.Elab.BuiltinTerm";
  "Lean.Elab.SetOption" -> "Lean.Elab.BuiltinTerm";
  "Lean.Elab.Eval" -> "Lean.Elab.BuiltinTerm";
  "Std.Tactic.Lint" -> "Mathlib.Tactic.Lint";
  "Lean.CoreM" -> "Mathlib.Lean.CoreM";
  "Lean" -> "Std.Tactic.Exact";
  "Lean.ImportingFlag" -> "Lean.Data.Options";
  "Lean.Data.KVMap" -> "Lean.Data.Options";
  "Lean.Data.NameMap" -> "Lean.Data.Options";
  "Lean.Meta.Instances" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.InlineAttrs" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.Closure" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.Types" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.MonadScope" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.Internalize" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.Level" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Lean.Compiler.LCNF.AuxDeclCache" -> "Lean.Compiler.LCNF.LambdaLifting";
  "Mathlib.Data.FunLike.Basic" -> "Mathlib.Data.FunLike.Embedding";
  "Lean.Meta.Tactic.Subst" -> "Lean.Meta.Match.CaseValues";
  "Lean.Meta.Tactic.Clear" -> "Lean.Meta.Match.CaseValues";
  "Lean.Meta.Match.Value" -> "Lean.Meta.Match.CaseValues";
  "Std.Logic" -> "Std.Classes.LawfulMonad";
  "Aesop.Util" -> "Aesop.Script";
  "Std.Lean.Meta.Clear" -> "Aesop.Script";
  "Std.Lean.Meta.Inaccessible" -> "Aesop.Script";
  "Std.Lean.HashSet" -> "Aesop.Script";
  "Init.Data.Array.Basic" -> "Init.Data.Array.BinSearch";
  "Std.Control.ForInStep.Lemmas" -> "Std.Data.List.Lemmas";
  "Std.Data.Nat.Lemmas" -> "Std.Data.List.Lemmas";
  "Std.Data.List.Basic" -> "Std.Data.List.Lemmas";
  "Std.Data.Option.Lemmas" -> "Std.Data.List.Lemmas";
  "Std.Classes.BEq" -> "Std.Data.List.Lemmas";
  "Std.Tactic.Ext" -> "Std.Data.List.Lemmas";
  "Std.Tactic.Simpa" -> "Std.Data.List.Lemmas";
  "Lean.Attributes" -> "Lean.Compiler.ExportAttr";
  "Qq.MetaM" -> "Qq.AssertInstancesCommute";
  "Mathlib.Data.Option.Defs" -> "Mathlib.Data.ListM.Basic";
  "Mathlib.Control.Basic" -> "Mathlib.Data.ListM.Basic";
  "Mathlib.Tactic.RunCmd" -> "Mathlib.Tactic.Conv";
  "Lean.Elab.Tactic.Conv.Basic" -> "Mathlib.Tactic.Conv";
  "Std.Lean.Parser" -> "Mathlib.Tactic.Conv";
  "Init.Data.Nat.Div" -> "Init.Data.Fin.Basic";
  "Init.Data.Nat.Bitwise" -> "Init.Data.Fin.Basic";
  "Init.Coe" -> "Init.Data.Fin.Basic";
  "Aesop.RuleTac" -> "Aesop.Search.Expansion.Norm";
  "Aesop.Search.Expansion.Basic" -> "Aesop.Search.Expansion.Norm";
  "Aesop.Search.Expansion.Simp" -> "Aesop.Search.Expansion.Norm";
  "Aesop.Search.RuleSelection" -> "Aesop.Search.Expansion.Norm";
  "Aesop.Search.SearchM" -> "Aesop.Search.Expansion.Norm";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.DependsOn";
  "Lean.Data.SMap" -> "Lean.Data.SSet";
  "Std.Logic" -> "Std.Data.Nat.Lemmas";
  "Std.Tactic.Basic" -> "Std.Data.Nat.Lemmas";
  "Std.Data.Nat.Init.Lemmas" -> "Std.Data.Nat.Lemmas";
  "Std.Data.Nat.Basic" -> "Std.Data.Nat.Lemmas";
  "Lean.Meta.KAbstract" -> "Lean.Meta.CasesOn";
  "Lean.Meta.Check" -> "Lean.Meta.CasesOn";
  "Init.Data.ByteArray.Basic" -> "Init.Data.ByteArray";
  "Std.Classes.Dvd" -> "Std.Data.Nat.Basic";
  "Lean" -> "Mathlib.Util.WithWeakNamespace";
  "Lean.Meta.Basic" -> "Lean.Meta.SynthInstance";
  "Lean.Meta.Instances" -> "Lean.Meta.SynthInstance";
  "Lean.Meta.AbstractMVars" -> "Lean.Meta.SynthInstance";
  "Lean.Meta.WHNF" -> "Lean.Meta.SynthInstance";
  "Lean.Meta.Check" -> "Lean.Meta.SynthInstance";
  "Lean.Util.Profile" -> "Lean.Meta.SynthInstance";
  "Lean.Meta.Instances" -> "Lean.Compiler.LCNF.Simp.Basic";
  "Lean.Compiler.InlineAttrs" -> "Lean.Compiler.LCNF.Simp.Basic";
  "Lean.Compiler.Specialize" -> "Lean.Compiler.LCNF.Simp.Basic";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.Simp.Basic";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.TerminationHint" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.PackDomain" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.PackMutual" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.Rel" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.Fix" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.Eqns" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Elab.PreDefinition.WF.Ite" -> "Lean.Elab.PreDefinition.WF.Main";
  "Lean.Data.AssocList" -> "Lean.Data.HashMap";
  "Lean.Parser.Attr" -> "Lean.Parser.Term";
  "Lean.Parser.Level" -> "Lean.Parser.Term";
  "Std.Logic" -> "Std.Data.Nat.Init.Lemmas";
  "Lean.Util.FindExpr" -> "Lean.Elab.StructInst";
  "Lean.Parser.Term" -> "Lean.Elab.StructInst";
  "Lean.Meta.Structure" -> "Lean.Elab.StructInst";
  "Lean.Elab.App" -> "Lean.Elab.StructInst";
  "Lean.Elab.Binders" -> "Lean.Elab.StructInst";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Data.Subtype";
  "Lean.Elab.PreDefinition.WF.Main" -> "Lean.Elab.PreDefinition.WF";
  "Lean" -> "Mathlib.Tactic.ApplyWith";
  "Std.Util.TermUnsafe" -> "Mathlib.Tactic.ApplyWith";
  "Lean.Meta.Match.Match" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Match.MatchEqsExt" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.Refl" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.Delta" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.SplitIf" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.Injection" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Meta.Tactic.Contradiction" -> "Lean.Meta.Match.MatchEqs";
  "Lean.Data.PersistentArray" -> "Lean.LocalContext";
  "Lean.Expr" -> "Lean.LocalContext";
  "Lean.Hygiene" -> "Lean.LocalContext";
  "Lean.Meta.CongrTheorems" -> "Std.Tactic.NormCast.Ext";
  "Lean.Meta.Tactic.Simp.SimpTheorems" -> "Std.Tactic.NormCast.Ext";
  "Std.Tactic.CoeExt" -> "Std.Tactic.NormCast.Ext";
  "Init.Data.Array.Basic" -> "Init.Data.Array.Mem";
  "Init.Data.Nat.Linear" -> "Init.Data.Array.Mem";
  "Init.Data.List.BasicAux" -> "Init.Data.Array.Mem";
  "Lean.Attributes" -> "Lean.Compiler.ImplementedByAttr";
  "Lean.Declaration" -> "Lean.Compiler.ImplementedByAttr";
  "Lean.MonadEnv" -> "Lean.Compiler.ImplementedByAttr";
  "Lean.Elab.InfoTree" -> "Lean.Compiler.ImplementedByAttr";
  "Lean.Meta.Tactic.Simp.Main" -> "Lean.Meta.Tactic.Split";
  "Lean.Meta.Tactic.SplitIf" -> "Lean.Meta.Tactic.Split";
  "Lean.Meta.Tactic.Apply" -> "Lean.Meta.Tactic.Split";
  "Lean.Meta.Tactic.Generalize" -> "Lean.Meta.Tactic.Split";
  "Lean.Data.HashMap" -> "Lean.Environment";
  "Lean.ImportingFlag" -> "Lean.Environment";
  "Lean.Data.SMap" -> "Lean.Environment";
  "Lean.Declaration" -> "Lean.Environment";
  "Lean.LocalContext" -> "Lean.Environment";
  "Lean.Util.Path" -> "Lean.Environment";
  "Lean.Util.FindExpr" -> "Lean.Environment";
  "Lean.Util.Profile" -> "Lean.Environment";
  "Lean.Util.InstantiateLevelParams" -> "Lean.Environment";
  "Init.Data.String.Basic" -> "Init.Util";
  "Init.Data.ToString.Basic" -> "Init.Util";
  "Lean.Exception" -> "Lean.Util.Trace";
  "Lean.Meta.Tactic.FVarSubst" -> "Lean.Meta.Tactic.Assert";
  "Lean.Meta.Tactic.Intro" -> "Lean.Meta.Tactic.Assert";
  "Lean.Meta.Tactic.Revert" -> "Lean.Meta.Tactic.Assert";
  "Lean.Meta.Basic" -> "Lean.Meta.Transform";
  "Lean.Meta.ForEachExpr" -> "Lean.Elab.DefView";
  "Lean.Elab.Command" -> "Lean.Elab.DefView";
  "Lean.Elab.DeclUtil" -> "Lean.Elab.DefView";
  "Init.Data.Array.Basic" -> "Init.Data.Array.InsertionSort";
  "Lean.Message" -> "Lean.Exception";
  "Lean.InternalExceptionId" -> "Lean.Exception";
  "Lean.Data.Options" -> "Lean.Exception";
  "Lean.Util.MonadCache" -> "Lean.Exception";
  "Init.Classical" -> "Init.System.ST";
  "Init.Control.EState" -> "Init.System.ST";
  "Init.Control.Reader" -> "Init.System.ST";
  "Lean.Meta.Transform" -> "Lean.Meta.Tactic.Delta";
  "Lean.Meta.Tactic.Replace" -> "Lean.Meta.Tactic.Delta";
  "Lean.Elab.Binders" -> "Lean.Elab.Command";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Command";
  "Mathlib.Init.Data.Quot" -> "Mathlib.Data.Quot";
  "Mathlib.Logic.Relator" -> "Mathlib.Data.Quot";
  "Lean" -> "Mathlib.Tactic.Replace";
  "Mathlib.Tactic.Have" -> "Mathlib.Tactic.Replace";
  "Mathlib.Tactic.Backtracking" -> "Mathlib.Tactic.SolveByElim";
  "Lean.Meta.Tactic.Apply" -> "Mathlib.Tactic.SolveByElim";
  "Mathlib.Lean.LocalContext" -> "Mathlib.Tactic.SolveByElim";
  "Mathlib.Tactic.Relation.Symm" -> "Mathlib.Tactic.SolveByElim";
  "Mathlib.Tactic.LabelAttr" -> "Mathlib.Tactic.SolveByElim";
  "Mathlib.Control.Basic" -> "Mathlib.Tactic.SolveByElim";
  "Std.Data.BinomialHeap.Basic" -> "Std.Data.BinomialHeap";
  "Std.Data.BinomialHeap.Lemmas" -> "Std.Data.BinomialHeap";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.Relation.Symm";
  "Lean.Elab.Tactic.Location" -> "Mathlib.Tactic.Relation.Symm";
  "Lean.Elab.Term" -> "Lean.Elab.Tactic.Basic";
  "Std.Classes.SetNotation" -> "Std.Data.List.Basic";
  "Std.Tactic.NoMatch" -> "Std.Data.List.Basic";
  "Std.Data.Option.Init.Lemmas" -> "Std.Data.List.Basic";
  "Std.Data.Array.Init.Lemmas" -> "Std.Data.List.Basic";
  "Lean.Elab.Util" -> "Lean.Elab.Attributes";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.ToExpr";
  "Mathlib.Data.FunLike.Equiv" -> "Mathlib.Logic.Equiv.Defs";
  "Mathlib.Data.Quot" -> "Mathlib.Logic.Equiv.Defs";
  "Mathlib.Init.Data.Bool.Lemmas" -> "Mathlib.Logic.Equiv.Defs";
  "Mathlib.Logic.Unique" -> "Mathlib.Logic.Equiv.Defs";
  "Lean.Meta.Tactic.Apply" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Lean.Meta.Tactic.Cases" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Lean.Meta.Tactic.Rename" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Lean.Elab.PreDefinition.Basic" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Lean.Elab.PreDefinition.WF.TerminationHint" -> "Lean.Elab.PreDefinition.WF.Rel";
  "Mathlib.Init.Control.Combinators" -> "Mathlib.Control.Basic";
  "Mathlib.Tactic.CasesM" -> "Mathlib.Control.Basic";
  "Mathlib.Tactic.Attr.Core" -> "Mathlib.Control.Basic";
  "Lean.LocalContext" -> "Std.Lean.Meta.LCtx";
  "Lean.Elab.Tactic.Basic" -> "Std.Lean.Tactic";
  "Lean.Meta.Eval" -> "Lean.Elab.Tactic.Config";
  "Lean.Elab.Tactic.Basic" -> "Lean.Elab.Tactic.Config";
  "Lean.Elab.SyntheticMVars" -> "Lean.Elab.Tactic.Config";
  "Lean.Linter.MissingDocs" -> "Lean.Elab.Tactic.Config";
  "Aesop.Search.Main" -> "Aesop.Main";
  "Aesop.BuiltinRules" -> "Aesop.Main";
  "Aesop.Frontend.Tactic" -> "Aesop.Main";
  "Aesop.Profiling" -> "Aesop.Main";
  "Aesop.Search.Expansion.Simp.Basic" -> "Aesop.Search.Expansion.Simp.SimpGoal";
  "Mathlib.Tactic.PushNeg" -> "Mathlib.Tactic.Contrapose";
  "Lean.Meta.AppBuilder" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.Induction" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.Injection" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.Assert" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.Subst" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.Acyclic" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Tactic.UnifyEq" -> "Lean.Meta.Tactic.Cases";
  "Lean.Meta.Basic" -> "Lean.Compiler.Specialize";
  "Lean.Attributes" -> "Lean.Compiler.Specialize";
  "Lean.Parser.Term" -> "Lean.Parser.Command";
  "Lean.Parser.Do" -> "Lean.Parser.Command";
  "Mathlib.Init.ZeroOne" -> "Mathlib.Init.Data.Nat.Basic";
  "Mathlib.Init.Data.Nat.Notation" -> "Mathlib.Init.Data.Nat.Basic";
  "Mathlib.Util.CompileInductive" -> "Mathlib.Init.Data.Nat.Basic";
  "Lean.Elab.Command" -> "Std.Tactic.Instances";
  "Lean.PrettyPrinter" -> "Std.Tactic.Instances";
  "Lean.Data.HashMap" -> "Mathlib.Util.MemoFix";
  "Lean.Parser.Basic" -> "Lean.Parser.Extension";
  "Lean.Compiler.InitAttr" -> "Lean.Parser.Extension";
  "Lean.ScopedEnvExtension" -> "Lean.Parser.Extension";
  "Lean.DocString" -> "Lean.Parser.Extension";
  "Lean.Meta.DiscrTree" -> "Std.Lean.Meta.DiscrTree";
  "Std.Data.Array.Merge" -> "Std.Lean.Meta.DiscrTree";
  "Std.Data.Ord" -> "Std.Lean.Meta.DiscrTree";
  "Std.Lean.Meta.Expr" -> "Std.Lean.Meta.DiscrTree";
  "Std.Lean.PersistentHashMap" -> "Std.Lean.Meta.DiscrTree";
  "Lean.CoreM" -> "Lean.Compiler.LCNF.Util";
  "Lean.MonadEnv" -> "Lean.Compiler.LCNF.Util";
  "Lean.Util.Recognizers" -> "Lean.Compiler.LCNF.Util";
  "Lean.Environment" -> "Lean.Util.PPExt";
  "Lean.MetavarContext" -> "Lean.Util.PPExt";
  "Lean.Data.OpenDecl" -> "Lean.Util.PPExt";
  "Lean.Elab.InfoTree.Types" -> "Lean.Util.PPExt";
  "Lean.Structure" -> "Lean.Meta.WHNF";
  "Lean.Util.Recognizers" -> "Lean.Meta.WHNF";
  "Lean.Meta.GetConst" -> "Lean.Meta.WHNF";
  "Lean.Meta.FunInfo" -> "Lean.Meta.WHNF";
  "Lean.Meta.Match.MatcherInfo" -> "Lean.Meta.WHNF";
  "Lean.Meta.Match.MatchPatternAttr" -> "Lean.Meta.WHNF";
  "Lean.HeadIndex" -> "Lean.Meta.KExprMap";
  "Lean.Meta.Basic" -> "Lean.Meta.KExprMap";
  "Lean.Attributes" -> "Std.Lean.NameMapAttribute";
  "Lean" -> "Mathlib.Tactic.Relation.Rfl";
  "Mathlib.Lean.Meta" -> "Mathlib.Tactic.Relation.Rfl";
  "Lean.PrettyPrinter.Delaborator.Options" -> "Lean.PrettyPrinter.Delaborator";
  "Lean.PrettyPrinter.Delaborator.SubExpr" -> "Lean.PrettyPrinter.Delaborator";
  "Lean.PrettyPrinter.Delaborator.TopDownAnalyze" -> "Lean.PrettyPrinter.Delaborator";
  "Lean.PrettyPrinter.Delaborator.Basic" -> "Lean.PrettyPrinter.Delaborator";
  "Lean.PrettyPrinter.Delaborator.Builtins" -> "Lean.PrettyPrinter.Delaborator";
  "Aesop.Percent" -> "Aesop.Constants";
  "Init.System.IO" -> "Lean.Data.Lsp.Communication";
  "Lean.Data.JsonRpc" -> "Lean.Data.Lsp.Communication";
  "Mathlib.Init.Algebra.Classes" -> "Mathlib.Data.Option.Defs";
  "Lean.Expr" -> "Lean.Util.FindLevelMVar";
  "Mathlib.Logic.Function.Basic" -> "Mathlib.Data.FunLike.Basic";
  "Mathlib.Tactic.NormCast" -> "Mathlib.Data.FunLike.Basic";
  "Std.Tactic.NormCast.Ext" -> "Std.Tactic.NormCast.Lemmas";
  "Lean.Elab.ElabRules" -> "Std.Tactic.NormCast.Lemmas";
  "Lean.MonadEnv" -> "Lean.LazyInitExtension";
  "Lean" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Init.Logic" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Init.Propext" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Logic.Basic" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Tactic.CasesM" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Tactic.Classical" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Tactic.Core" -> "Mathlib.Tactic.Tauto";
  "Mathlib.Tactic.SolveByElim" -> "Mathlib.Tactic.Tauto";
  "Qq" -> "Mathlib.Tactic.Tauto";
  "Lean.Data.Format" -> "Lean.Compiler.IR.UnboxResult";
  "Lean.Compiler.IR.Basic" -> "Lean.Compiler.IR.UnboxResult";
  "Mathlib.Init.Algebra.Order" -> "Mathlib.Init.Data.Int.Order";
  "Mathlib.Init.Data.Int.Basic" -> "Mathlib.Init.Data.Int.Order";
  "Lean.Expr" -> "Lean.HeadIndex";
  "Aesop.Main" -> "Aesop";
  "Lean.Util.CollectMVars" -> "Lean.Meta.LevelDefEq";
  "Lean.Meta.Basic" -> "Lean.Meta.LevelDefEq";
  "Lean.Meta.InferType" -> "Lean.Meta.LevelDefEq";
  "Lean.Meta.DecLevel" -> "Lean.Meta.LevelDefEq";
  "Lean.Data.Lsp.Internal" -> "Lean.Server.References";
  "Lean.Server.Utils" -> "Lean.Server.References";
  "Lean.Meta.SizeOf" -> "Lean.Elab.Deriving.SizeOf";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.SizeOf";
  "Lean.Log" -> "Lean.Elab.DeclarationRange";
  "Lean.Parser.Command" -> "Lean.Elab.DeclarationRange";
  "Lean.DeclarationRange" -> "Lean.Elab.DeclarationRange";
  "Lean.Data.Lsp.Utf16" -> "Lean.Elab.DeclarationRange";
  "Std.Data.Rat.Basic" -> "Std.Classes.RatCast";
  "Init.SimpLemmas" -> "Init.Data.Nat.Basic";
  "Init.Data.Nat.Basic" -> "Init.Data.Nat.Bitwise";
  "Init.Data.Nat.Div" -> "Init.Data.Nat.Bitwise";
  "Init.Coe" -> "Init.Data.Nat.Bitwise";
  "Lean.Data.RBMap" -> "Lean.Data.Xml.Basic";
  "Init.Prelude" -> "Init.Core";
  "Init.SizeOf" -> "Init.Core";
  "Lean" -> "Mathlib.Tactic.Rename";
  "Aesop.Util" -> "Aesop.Rule.Name";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Propext";
  "Mathlib.Mathport.Rename" -> "Mathlib.Init.Propext";
  "Lean.Parser.Term" -> "Mathlib.Tactic.UnsetOption";
  "Lean.Parser.Do" -> "Mathlib.Tactic.UnsetOption";
  "Lean.Elab.Command" -> "Mathlib.Tactic.UnsetOption";
  "Mathlib.Data.KVMap" -> "Mathlib.Tactic.UnsetOption";
  "Lean.Meta.Check" -> "Lean.Meta.Tactic.LinearArith.Nat.Basic";
  "Lean.Meta.Offset" -> "Lean.Meta.Tactic.LinearArith.Nat.Basic";
  "Lean.Meta.KExprMap" -> "Lean.Meta.Tactic.LinearArith.Nat.Basic";
  "Lean.Meta.Inductive" -> "Lean.Elab.Deriving.Hashable";
  "Lean.Elab.Deriving.Basic" -> "Lean.Elab.Deriving.Hashable";
  "Lean.Elab.Deriving.Util" -> "Lean.Elab.Deriving.Hashable";
  "Lean.Elab.PreDefinition.Structural.Main" -> "Lean.Elab.PreDefinition.Structural";
  "Lean.Meta.Basic" -> "Lean.Meta.Tactic.ElimInfo";
  "Lean.Meta.Check" -> "Lean.Meta.Tactic.ElimInfo";
  "Lean.ScopedEnvExtension" -> "Lean.Meta.Tactic.ElimInfo";
  "Lean.Expr" -> "Lean.Compiler.LCNF.FVarUtil";
  "Lean.Compiler.LCNF.Basic" -> "Lean.Compiler.LCNF.FVarUtil";
  "Lean.Compiler.LCNF.CompilerM" -> "Lean.Compiler.LCNF.FVarUtil";
  "Lean" -> "Mathlib.Tactic.SimpRw";
  "Lean.PrettyPrinter" -> "Std.Lean.Delaborator";
  "Lean.Meta.Transform" -> "Lean.Compiler.LCNF.ToDecl";
  "Lean.Meta.Match.MatcherInfo" -> "Lean.Compiler.LCNF.ToDecl";
  "Lean.Compiler.ImplementedByAttr" -> "Lean.Compiler.LCNF.ToDecl";
  "Lean.Compiler.LCNF.ToLCNF" -> "Lean.Compiler.LCNF.ToDecl";
  "Lean.Parser.Term" -> "Lean.Parser.Tactic";
  "Mathlib.Init.Logic" -> "Mathlib.Init.Algebra.Classes";
  "Mathlib.Init.Data.Ordering.Basic" -> "Mathlib.Init.Algebra.Classes";
  "Lean.Util.Recognizers" -> "Lean.Meta.MatchUtil";
  "Lean.Meta.Basic" -> "Lean.Meta.MatchUtil";
  "Lean" -> "Mathlib.Tactic.SplitIfs";
  "Mathlib.Init.Logic" -> "Mathlib.Tactic.SplitIfs";
  "Mathlib.Tactic.Core" -> "Mathlib.Tactic.SplitIfs";
  "Lean.Meta.Basic" -> "Lean.Meta.Match.MatchEqsExt";
  "Lean.Environment" -> "Lean.Compiler.NeverExtractAttr";
  "Lean.Attributes" -> "Lean.Compiler.NeverExtractAttr";
}