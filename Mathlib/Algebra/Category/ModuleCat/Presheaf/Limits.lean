import Mathlib.Algebra.Category.ModuleCat.Presheaf
import Mathlib.Algebra.Category.ModuleCat.Limits
import Mathlib.Algebra.Category.ModuleCat.Colimits
import Mathlib.CategoryTheory.Limits.Preserves.Limits

universe v u‚ÇÇ v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÉ u

namespace AddCommGroupCat

open CategoryTheory

lemma isIso_iff_bijective {M N : AddCommGroupCat} (f : M ‚ü∂ N) :
    IsIso f ‚Üî Function.Bijective f := by
  constructor
  ¬∑ intro hf
    rw [Function.bijective_iff_has_inverse]
    exact ‚ü®inv f, fun x => by rw [‚Üê comp_apply, IsIso.hom_inv_id, id_apply],
      fun x => by rw [‚Üê comp_apply, IsIso.inv_hom_id, id_apply]‚ü©
  ¬∑ intro H
    obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := Function.bijective_iff_has_inverse.1 H
    refine' ‚ü®AddMonoidHom.mk' g _, _, _‚ü©
    ¬∑ intro a b
      change ‚àÄ _, _ at hg‚ÇÇ
      apply H.injective
      simp only [map_add, hg‚ÇÇ]
    ¬∑ ext x
      apply hg‚ÇÅ
    ¬∑ ext x
      apply hg‚ÇÇ

end AddCommGroupCat

namespace ModuleCat

open CategoryTheory Limits

instance (R : Type u‚ÇÅ) [Ring R] :
    ReflectsIsomorphisms (forget‚ÇÇ (ModuleCat.{v} R) AddCommGroupCat) :=
  ‚ü®fun {A B} f hf => by
    let F := forget‚ÇÇ (ModuleCat.{v} R) AddCommGroupCat
    let g := inv (F.map f)
    have hf' : Function.Bijective f :=
      (AddCommGroupCat.isIso_iff_bijective (F.map f)).1 inferInstance
    have h‚ÇÅ : ‚àÄ (b : B), f (g b) = b := fun b => by
      change (g ‚â´ F.map f) b = b
      simp only [IsIso.inv_hom_id, forget‚ÇÇ_obj, AddCommGroupCat.coe_id, id_eq]
    refine' ‚ü®‚ü®‚ü®g, g.map_add‚ü© , _‚ü©, _, _‚ü©
    ¬∑ intro r b
      apply hf'.injective
      change f (g (r ‚Ä¢ b)) = f (r ‚Ä¢ _)
      rw [h‚ÇÅ, map_smul, h‚ÇÅ]
    ¬∑ exact F.map_injective (IsIso.hom_inv_id (F.map f))
    ¬∑ exact F.map_injective (IsIso.inv_hom_id (F.map f))‚ü©

lemma isIso_iff_bijective {R : Type u} [Ring R] {M N : ModuleCat R} (f : M ‚ü∂ N) :
    IsIso f ‚Üî Function.Bijective f := by
  constructor
  ¬∑ intro
    have h : IsIso ((forget‚ÇÇ _ AddCommGroupCat).map f) := inferInstance
    rw [AddCommGroupCat.isIso_iff_bijective] at h
    exact h
  ¬∑ intro hf
    have : IsIso ((forget‚ÇÇ (ModuleCat R) AddCommGroupCat).map f) :=
      (AddCommGroupCat.isIso_iff_bijective _).2 hf
    exact isIso_of_reflects_iso f (forget‚ÇÇ (ModuleCat R) AddCommGroupCat)

lemma hasLimitsOfShape (J : Type u‚ÇÇ) [SmallCategory J] (R : Type u‚ÇÅ) [Ring R] :
    HasLimitsOfShape J (ModuleCatMax.{u‚ÇÇ, v} R) := by
  -- TODO: make explicit parameters for `ModuleCat.hasLimitsOfSize.{u‚ÇÇ, v}`
  have : HasLimitsOfSize.{u‚ÇÇ, u‚ÇÇ} (ModuleCatMax.{u‚ÇÇ, v} R) := hasLimitsOfSize.{u‚ÇÇ, v}
  apply HasLimitsOfSize.has_limits_of_shape

noncomputable def forget‚ÇÇPreservesLimitsOfShape (J : Type u‚ÇÇ) [SmallCategory J] (R : Type u‚ÇÅ) [Ring R] :
    PreservesLimitsOfShape J (forget‚ÇÇ (ModuleCat.{max u‚ÇÇ v} R) AddCommGroupCat) := by
  have : PreservesLimitsOfSize.{u‚ÇÇ, u‚ÇÇ} (forget‚ÇÇ (ModuleCat.{max u‚ÇÇ v} R) AddCommGroupCat) :=
  -- TODO: make explicit parameters for `ModuleCat.forget‚ÇÇAddCommGroupPreservesLimitsOfSize`
    forget‚ÇÇAddCommGroupPreservesLimitsOfSize.{u‚ÇÇ, v}
  infer_instance

noncomputable def forget‚ÇÇReflectsLimitsOfShape (J : Type u‚ÇÇ) [SmallCategory J] (R : Type u‚ÇÅ) [Ring R] :
    ReflectsLimitsOfShape J (forget‚ÇÇ (ModuleCat.{max u‚ÇÇ v} R) AddCommGroupCat) := by
  have := hasLimitsOfShape.{v} J R
  have := forget‚ÇÇPreservesLimitsOfShape.{v} J R
  exact reflectsLimitsOfShapeOfReflectsIsomorphisms

noncomputable def restrictScalarsPreservesLimitsOfShape (J : Type u‚ÇÇ) [SmallCategory J] {R : Type u‚ÇÅ} {S : Type u‚ÇÉ}
    [Ring R] [Ring S] (f : R ‚Üí+* S) :
    PreservesLimitsOfShape J (restrictScalars.{max u‚ÇÇ v} f) where
  preservesLimit {K} := ‚ü®fun {c} hc => by
    have := forget‚ÇÇReflectsLimitsOfShape.{v} J R
    have := forget‚ÇÇPreservesLimitsOfShape.{v} J S
    refine' @isLimitOfReflects _ _ _ _ _ _ _ (forget‚ÇÇ (ModuleCat.{max u‚ÇÇ v} R) AddCommGroupCat) ((restrictScalars f).mapCone c) _ _
    exact isLimitOfPreserves (forget‚ÇÇ (ModuleCat.{max u‚ÇÇ v} S) AddCommGroupCat) hc‚ü©

noncomputable instance forget‚ÇÇPreservesColimitsOfShape (J : Type u) [SmallCategory J] (R : Type u) [Ring R] :
    PreservesColimitsOfShape J (forget‚ÇÇ (ModuleCat.{u} R) AddCommGroupCat) := by
  sorry

noncomputable instance forget‚ÇÇReflectsColimitsOfShape (J : Type u) [SmallCategory J] (R : Type u) [Ring R] :
    ReflectsColimitsOfShape J (forget‚ÇÇ (ModuleCat.{u} R) AddCommGroupCat) :=
  reflectsColimitsOfShapeOfReflectsIsomorphisms

noncomputable instance restrictScalarsPreservesColimitsOfShape (J : Type u) [SmallCategory J] {R S : Type u}
    [Ring R] [Ring S] (f : R ‚Üí+* S) :
    PreservesColimitsOfShape J (ModuleCat.restrictScalars.{u} f) where
  preservesColimit {K} := ‚ü®fun {c} hc => by
    refine' @isColimitOfReflects _ _ _ _ _ _ _ (forget‚ÇÇ (ModuleCat.{u} R) AddCommGroupCat) ((restrictScalars f).mapCocone c) _ _
    exact isColimitOfPreserves (forget‚ÇÇ (ModuleCat S) AddCommGroupCat) hc‚ü©

end ModuleCat

namespace PresheafOfModules

open CategoryTheory Category Limits

section

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {R : C·µí·µñ ‚•§ RingCat.{u}}
  {J : Type u‚ÇÇ} [SmallCategory J] (F : J ‚•§ PresheafOfModules.{max u‚ÇÇ v} R)

def evaluationJointlyReflectsLimits (c : Cone F)
    (hc : ‚àÄ (X : C·µí·µñ), IsLimit ((evaluation R X).mapCone c)) : IsLimit c := by
  letI : ‚àÄ {X Y : C·µí·µñ} (f : X ‚ü∂ Y),
    PreservesLimitsOfShape J (ModuleCat.restrictScalars (R.map f)) := fun f =>
      ModuleCat.restrictScalarsPreservesLimitsOfShape.{v} _ _
  exact
  { lift := fun s => Hom.mk'' (fun X => (hc X).lift ((evaluation R X).mapCone s)) (fun X Y f => by
      apply (isLimitOfPreserves (ModuleCat.restrictScalars (R.map f)) (hc Y)).hom_ext
      intro j
      simp only [Functor.mapCone_œÄ_app, Category.assoc, ‚Üê Functor.map_comp]
      erw [IsLimit.fac, ‚Üê NatTrans.naturality, ‚Üê NatTrans.naturality, IsLimit.fac_assoc]
      rfl)
    fac := fun s j => by
      ext1 X
      exact (hc X).fac ((evaluation R X).mapCone s) j
    uniq := fun s m hm => by
      ext1 X
      exact (hc X).uniq ((evaluation R X).mapCone s) ((evaluation R X).map m) (fun j => by
        dsimp
        rw [‚Üê hm]
        rfl) }

@[simps]
noncomputable def limitBundledMkStruct : BundledMkStruct R := by
  letI : ‚àÄ (X : C·µí·µñ), HasLimitsOfShape J (ModuleCat.{max u‚ÇÇ v} (R.obj X)) :=
    fun _ => ModuleCat.hasLimitsOfShape.{v} _ _
  letI : ‚àÄ {X Y : C·µí·µñ} (f : X ‚ü∂ Y),
      PreservesLimitsOfShape J (ModuleCat.restrictScalars (R.map f)) :=
    fun f => ModuleCat.restrictScalarsPreservesLimitsOfShape.{v} _ _
  exact
  { obj := fun X => limit (F ‚ãô evaluation R X)
    map := fun {X Y} f => limMap (whiskerLeft F (restriction R f)) ‚â´ (preservesLimitIso ((ModuleCat.restrictScalars (R.map f))) (F ‚ãô evaluation R Y)).inv
    map_id := fun X => by
      dsimp
      simp only [‚Üê cancel_mono (preservesLimitIso ((ModuleCat.restrictScalars (R.map (ùüô X)))) (F ‚ãô evaluation R X)).hom]
      simp only [assoc, Iso.inv_hom_id, comp_id]
      apply limit.hom_ext
      intro j
      erw [limMap_œÄ, assoc, preservesLimitsIso_hom_œÄ]
      simp only [‚Üê cancel_mono ((ModuleCat.restrictScalarsId' (R.map (ùüô X)) (R.map_id X)).hom.app ((F.obj j).obj X)),
        Functor.comp_obj, evaluation_obj, whiskerLeft_app, restriction_app_id,
        Functor.id_obj, assoc, Iso.inv_hom_id_app, comp_id, NatTrans.naturality,
        Functor.id_map, Iso.inv_hom_id_app_assoc]
    map_comp := fun {X Y Z} f g => by
      dsimp
      simp only [‚Üê cancel_mono (preservesLimitIso ((ModuleCat.restrictScalars (R.map (f ‚â´ g)))) (F ‚ãô evaluation R Z)).hom,
        assoc, Iso.inv_hom_id, comp_id]
      apply limit.hom_ext
      intro j
      simp only [limMap_œÄ, Functor.comp_obj, evaluation_obj, whiskerLeft_app,
        Functor.map_comp, assoc, restriction_app_comp]
      erw [preservesLimitsIso_hom_œÄ, ‚Üê NatTrans.naturality]
      dsimp
      simp only [‚Üê Functor.map_comp_assoc]
      erw [preservesLimitsIso_inv_œÄ, limMap_œÄ, Functor.map_comp_assoc,
        preservesLimitsIso_inv_œÄ_assoc, limMap_œÄ_assoc]
      rfl }

noncomputable def limitCone : Cone F := by
  letI : ‚àÄ (X : C·µí·µñ), HasLimitsOfShape J (ModuleCat.{max u‚ÇÇ v} (R.obj X)) :=
    fun _ => ModuleCat.hasLimitsOfShape.{v} _ _
  letI : ‚àÄ {X Y : C·µí·µñ} (f : X ‚ü∂ Y),
      PreservesLimitsOfShape J (ModuleCat.restrictScalars (R.map f)) :=
    fun f => ModuleCat.restrictScalarsPreservesLimitsOfShape.{v} _ _
  exact
  { pt := mk'' (limitBundledMkStruct.{v} F)
    œÄ :=
      { app := fun j => Hom.mk'' (fun X => limit.œÄ (F ‚ãô evaluation R X) j) (fun X Y f => by
          dsimp
          simp only [assoc, preservesLimitsIso_inv_œÄ]
          apply limMap_œÄ)
        naturality := fun i j œÜ => by
          dsimp
          erw [id_comp]
          ext1 X
          simp only [mk''_obj, limitBundledMkStruct_obj, Hom.mk''_app, Hom.comp_app]
          exact (limit.w (F ‚ãô evaluation R X) œÜ).symm } }

noncomputable def isLimitLimitCone : IsLimit (limitCone.{v} F) := by
  letI : ‚àÄ (X : C·µí·µñ), HasLimitsOfShape J (ModuleCat.{max u‚ÇÇ v} (R.obj X)) :=
    fun _ => ModuleCat.hasLimitsOfShape.{v} _ _
  exact evaluationJointlyReflectsLimits.{v} _ _ (fun _ => limit.isLimit _)

variable (R J)

lemma hasLimitsOfShape : HasLimitsOfShape J (PresheafOfModules.{max u‚ÇÇ v} R) where
  has_limit F := ‚ü®_, isLimitLimitCone.{v} F‚ü©

attribute [instance] hasLimitsOfShape

noncomputable def evaluationPreservesLimitsOfShape (X : C·µí·µñ) :
    PreservesLimitsOfShape J (evaluation R X : PresheafOfModules.{max u‚ÇÇ v} R ‚•§ _) where
  preservesLimit := fun {K} => by
    letI : HasLimitsOfShape J (ModuleCat.ModuleCatMax.{u‚ÇÇ, v} (R.obj X)) :=
      ModuleCat.hasLimitsOfShape _ _
    exact preservesLimitOfPreservesLimitCone (isLimitLimitCone.{v} K) (limit.isLimit _)

instance : HasFiniteLimits (PresheafOfModules.{v} R) :=
  ‚ü®fun _ => inferInstance‚ü©

noncomputable instance (X : C·µí·µñ) : PreservesFiniteLimits (evaluation.{v} R X) :=
  ‚ü®fun _ _ _ => evaluationPreservesLimitsOfShape.{v} _ _ _‚ü©

instance (J : Type v) [SmallCategory J] : HasLimitsOfShape J (PresheafOfModules.{v} R) := by
  apply hasLimitsOfShape.{v}

noncomputable instance (J : Type v) [SmallCategory J] (X : C·µí·µñ) :
    PreservesLimitsOfShape J (evaluation.{v} R X) :=
  evaluationPreservesLimitsOfShape.{v, v} _ _ _

end

section

-- `J : Type u` for now
variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {R : C·µí·µñ ‚•§ RingCat.{u}}
  {J : Type u} [SmallCategory J] (F : J ‚•§ PresheafOfModules.{u} R)

def evaluationJointlyReflectsColimits (c : Cocone F)
    (hc : ‚àÄ (X : C·µí·µñ), IsColimit ((evaluation R X).mapCocone c)) : IsColimit c := by
  exact
  { desc := fun s => Hom.mk'' (fun X => (hc X).desc ((evaluation R X).mapCocone s)) (fun X Y f => by
      apply (hc X).hom_ext
      intro j
      erw [(hc X).fac_assoc, (restriction R f).naturality_assoc]
      dsimp
      rw [‚Üê Functor.map_comp]
      erw [(ModuleCat.restrictScalars (R.map f)).congr_map ((hc Y).fac ((evaluation R Y).mapCocone s) j),
        (restriction R f).naturality]
      rfl )
    fac := fun s j => by
      ext1 X
      exact (hc X).fac ((evaluation R X).mapCocone s) j
    uniq := fun s m hm => by
      ext1 X
      exact (hc X).uniq ((evaluation R X).mapCocone s) ((evaluation R X).map m) (fun j => by
        dsimp
        rw [‚Üê hm]
        rfl) }

@[simps]
noncomputable def colimitBundledMkStruct : BundledMkStruct.{u} R := by
  exact
  { obj := fun X => colimit (F ‚ãô evaluation R X)
    map := fun {X Y} f => colimMap (whiskerLeft F (restriction R f)) ‚â´
        (preservesColimitIso (ModuleCat.restrictScalars (R.map f)) (F ‚ãô evaluation R Y)).inv
    map_id := fun X => by
      apply colimit.hom_ext
      intro j
      dsimp
      simp only [Functor.comp_obj, evaluation_obj, Œπ_colimMap_assoc, whiskerLeft_app,
        restriction_app_id]
      erw [Œπ_preservesColimitsIso_inv (ModuleCat.restrictScalars (R.map (ùüô X))) (F ‚ãô evaluation R X),
        ‚Üê NatTrans.naturality]
      rfl
    map_comp := fun {X Y Z} f g => by
      apply colimit.hom_ext
      intro j
      dsimp
      simp only [Œπ_colimMap_assoc, Functor.comp_obj, evaluation_obj, whiskerLeft_app,
        Functor.map_comp, assoc, restriction_app_comp]
      erw [Œπ_preservesColimitsIso_inv_assoc (ModuleCat.restrictScalars (R.map f)) (F ‚ãô evaluation R Y) j]
      simp only [‚Üê Functor.map_comp_assoc, Œπ_colimMap_assoc]
      congr 1
      erw [Œπ_preservesColimitsIso_inv (ModuleCat.restrictScalars (R.map g)) (F ‚ãô evaluation R Z) j]
      erw [Œπ_preservesColimitsIso_inv (ModuleCat.restrictScalars (R.map (f ‚â´ g))) (F ‚ãô evaluation R Z) j]
      simp only [Functor.comp_obj, evaluation_obj, Functor.map_comp, whiskerLeft_app, assoc]
      erw [‚Üê NatTrans.naturality]
      rfl }

noncomputable def colimitCocone : Cocone F := by
  exact
  { pt := mk'' (colimitBundledMkStruct F)
    Œπ :=
      { app := fun j => Hom.mk'' (fun X => colimit.Œπ (F ‚ãô evaluation R X) j) (fun X Y f => by
          dsimp
          erw [Œπ_colimMap_assoc]
          simp
          congr 1
          dsimp
          erw [Œπ_preservesColimitsIso_inv (ModuleCat.restrictScalars (R.map f))])
        naturality := fun i j œÜ => by
          dsimp
          rw [comp_id]
          ext1 X
          simp only [mk''_obj, colimitBundledMkStruct_obj, Hom.comp_app, Hom.mk'_app]
          exact (colimit.w (F ‚ãô evaluation R X) œÜ) } }

noncomputable def isColimitColimitCocone : IsColimit (colimitCocone F) :=
  evaluationJointlyReflectsColimits _ _ (fun _ => colimit.isColimit _)

variable (R J)

instance : HasColimitsOfShape J (PresheafOfModules.{u} R) where
  has_colimit F := ‚ü®_, isColimitColimitCocone F‚ü©

instance : HasColimitsOfSize.{u, u} (PresheafOfModules.{u} R) where

noncomputable instance (X : C·µí·µñ) : PreservesColimitsOfShape J (evaluation R X) where
  preservesColimit := fun {K} => by
    exact preservesColimitOfPreservesColimitCocone (isColimitColimitCocone K) (colimit.isColimit _)

noncomputable instance (X : C·µí·µñ) : PreservesColimitsOfSize.{u, u} (evaluation R X) where

instance : HasFiniteColimits (PresheafOfModules.{u} R) :=
  hasFiniteColimits_of_hasColimitsOfSize.{u, u} (PresheafOfModules.{u} R)

noncomputable instance (X : C·µí·µñ) : PreservesFiniteColimits (evaluation.{u} R X) :=
  PreservesColimitsOfSize.preservesFiniteColimits.{u, u} _

end

end PresheafOfModules
