/-
Copyright (c) 2023 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import Mathlib.Data.ListM.Basic

/-!
# Depth first search

We perform depth first search of a tree or graph,
where the neighbours of a vertex are provided by a lazy list `α → ListM m α`.

This is useful in meta code for searching for solutions in the presence of alternatives.
It can be nice to represent the choices via a lazy list,
the later choices don't need to be evaluated while we do depth first search on earlier choices.
-/

namespace ListM

variable [Monad m]

/-- A generalisation of `depthFirst`, which allows the generation function to know the current
depth, and to count the depth starting from a specified value. -/
unsafe def depthFirst' (f : Nat → α → ListM m α) (n : Nat) (a : α) : ListM m α :=
cons do pure (some a, ((f n a).map (depthFirst' f (n+1))).join)

/--
The lazy list recording the depth first search of a graph generated by a function
`f : α → ListM m α`.

The option `maxDepth` limits the search depth.

Note that if the graph is not a tree then elements will be visited multiple times.
(See `depthFirstRemovingDuplicates`)
-/
unsafe def depthFirst (f : α → ListM m α) (a : α) (maxDepth : Option Nat := none) : ListM m α :=
match maxDepth with
| some d => depthFirst' (fun n a => if n ≤ d then f a else empty) 0 a
| none => depthFirst' (fun _ a => f a) 0 a

open Lean in
/--
Variant of `depthFirst`,
using an internal `HashSet` to record and avoid already visited nodes.

This is potentially very expensive.
If you want to do efficient enumerations from a generation function,
avoiding duplication up to equality or isomorphism,
use Brendan McKay's generation by canonical construction path method.
-/
unsafe def depthFirstRemovingDuplicates [BEq α] [Hashable α] [Alternative m]
    (f : α → ListM m α) (a : α)
    (maxDepth : Option Nat := none) : ListM m α :=
let f' : α → ListM (StateT (HashSet α) m) α := fun a =>
  (f a).liftM.filterMapM fun b => do
    let s ← get
    if s.contains b then failure
    set <| s.insert b
    pure b
(depthFirst f' a maxDepth).run' (HashSet.empty.insert a)
